{"version":3,"sources":["2packES6.js"],"names":["packer","module","Uint8Array","prototype","slice","Object","defineProperty","Array","bPack","holyBuffer","Buffer","MAX_ARGUMENTS_LENGTH","K_MAX_LENGTH","allocUnsafe","allocUnsafeSlow","byteLength","create","write","toString","length","RangeError","buf","string","utf8ToBytes","offset","remaining","blitBuffer","encoding","start","end","utf8Slice","units","Infinity","codePoint","leadSurrogate","bytes","i","charCodeAt","push","Error","Math","min","res","firstByte","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","swap","b","n","m","codePoints","len","String","fromCharCode","apply","isBigEndian","a","Uint32Array","buffer","byteOffset","isBE","isLE","schema","dataHolderAsArray","holderRecreated","TYPE_BIN","TYPE_STR","TYPE_INT","TYPE_UINT","TYPE_FLOAT","TYPE_JSON","isPrimitive","schLen","fields","buffers","zeroUI16","pktOffset","pktDataHolderArr","pktDataHolderObj","pktMinSize","pktDynamicSize","pktBufStrict","pktBufPack","e","split","name","shift","subType","type","getTypeId","replace","size","parseInt","buildTypedBuf","bufType","bufAType","bufBytes","bufABytes","value","pack","unpack","data","target","isArray","tIdx","fieldIdx","pktSize","field","input","JSON","stringify","_blen","isNaN","isFinite","reverse","l","bin","cbEndInfo","asArray","asCopy","curOffset","pktOffsetStart","byteLen","needMem","parse","Uint16Array","BYTES_PER_ELEMENT","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","src","dst","dstLen","srcLen","t","exports"],"mappings":";;;;;;AAAA,IAAMA,SAAU,UAASC,MAAT,EAAiB;AACT,QAAG,CAACC,WAAWC,SAAX,CAAqBC,KAAzB,EAAgC;AAC5BC,eAAOC,cAAP,CAAsBJ,WAAWC,SAAjC,EAA4C,OAA5C,EAAqD;AACjD,qBAASI,MAAMJ,SAAN,CAAgBC;AADwB,SAArD;AAGH;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,QAAMI,QAAS,YAAW;AACtB,YAAMC,aAAc,OAAOC,MAAP,KAAmB,WAAnB,GAAiCA,MAAjC,GAA2C,YAAW;AAClE,gBAAMC,uBAAuB,MAA7B;AACA,gBAAMC,eAAe,UAArB;;AAEA;;AAEA,mBAAQ,YAAW;AACf,oBAAMF,SAAS,SAATA,MAAS,GAAW,CAAE,CAA5B;;AAEA;;AAEAA,uBAAOG,WAAP,GAAqBA,WAArB;AACAH,uBAAOI,eAAP,GAAyBD,WAAzB;AACAH,uBAAOK,UAAP,GAAoBA,UAApB;;AAEAL,uBAAOP,SAAP,GAAmBE,OAAOW,MAAP,CAAc,IAAd,CAAnB;AACAN,uBAAOP,SAAP,CAAiBc,KAAjB,GAAyBA,KAAzB;AACAP,uBAAOP,SAAP,CAAiBe,QAAjB,GAA4BA,QAA5B;;AAEA;;AAEA,uBAAOR,MAAP;;AAEA;;AAEA,yBAASG,WAAT,CAAqBM,MAArB,EAA6B;AACzB,wBAAGA,SAASP,YAAZ,EAA0B;AACtB,8BAAM,IAAIQ,UAAJ,CAAe,4BAAf,CAAN;AACH;;AAED,wBAAMC,MAAM,IAAInB,UAAJ,CAAeiB,MAAf,CAAZ;;AAEA;AACAE,wBAAIJ,KAAJ,GAAYP,OAAOP,SAAP,CAAiBc,KAA7B;AACAI,wBAAIH,QAAJ,GAAeR,OAAOP,SAAP,CAAiBe,QAAhC;;AAEA,2BAAOG,GAAP;AACH;;AAED,yBAASN,UAAT,CAAoBO,MAApB,EAA4B;AACxB,2BAAOC,YAAYD,MAAZ,EAAoBH,MAA3B;AACH;;AAED;;AAEA,yBAASF,KAAT,CAAeK,MAAf,EAAuBE,MAAvB,EAA+BL,MAA/B,EAAuC;AACnCK,6BAASA,UAAU,CAAnB;AACAL,6BAASA,UAAU,KAAKA,MAAxB;;AAEA,wBAAMM,YAAY,KAAKN,MAAL,GAAcK,MAAhC;;AAEA,wBAAG,CAACL,MAAD,IAAWA,SAASM,SAAvB,EAAkC;AAC9BN,iCAASM,SAAT;AACH;;AAED,2BAAOC,WAAWH,YAAYD,MAAZ,EAAoB,KAAKH,MAAL,GAAcK,MAAlC,CAAX,EAAsD,IAAtD,EAA4DA,MAA5D,EAAoEL,MAApE,CAAP;AACH;;AAED,yBAASD,QAAT,CAAkBS,QAAlB,EAA4BC,KAA5B,EAAmCC,GAAnC,EAAwC;AACpCD,4BAAQA,SAAS,CAAjB;AACAC,0BAAMA,OAAO,KAAKV,MAAlB;;AAEA,2BAAOU,QAAQ,CAAR,GAAY,EAAZ,GAAiBC,UAAU,IAAV,EAAgBF,KAAhB,EAAuBC,GAAvB,CAAxB;AACH;AACJ,aA1DM,EAAP;;AA4DA;;AAEA,qBAASN,WAAT,CAAqBD,MAArB,EAA6BS,KAA7B,EAAoC;AAChCA,wBAAQA,SAASC,QAAjB;;AAEA,oBAAMb,SAASG,OAAOH,MAAtB;;AAEA,oBAAIc,kBAAJ;AACA,oBAAIC,gBAAgB,IAApB;AACA,oBAAIC,QAAQ,IAAI5B,KAAJ,EAAZ;;AAEA,qBAAI,IAAI6B,IAAI,CAAZ,EAAeA,IAAIjB,MAAnB,EAA2B,EAAEiB,CAA7B,EAAgC;AAC5BH,gCAAYX,OAAOe,UAAP,CAAkBD,CAAlB,CAAZ;;AAEA;AACA,wBAAGH,YAAY,MAAZ,IAAsBA,YAAY,MAArC,EAA6C;AACzC;AACA,4BAAG,CAACC,aAAJ,EAAmB;AACf;AACA,gCAAGD,YAAY,MAAf,EAAuB;AACnB;AACA,oCAAG,CAACF,SAAS,CAAV,IAAe,CAAC,CAAnB,EAAsB;AAClBI,0CAAMG,IAAN,CAAW,IAAX,EAAiB,IAAjB,EAAuB,IAAvB;AACH;;AAED;AACH,6BAPD,MAQK,IAAGF,IAAI,CAAJ,KAAUjB,MAAb,EAAqB;AACtB;AACA,oCAAG,CAACY,SAAS,CAAV,IAAe,CAAC,CAAnB,EAAsB;AAClBI,0CAAMG,IAAN,CAAW,IAAX,EAAiB,IAAjB,EAAuB,IAAvB;AACH;;AAED;AACH;;AAED;AACAJ,4CAAgBD,SAAhB;;AAEA;AACH;;AAED;AACA,4BAAGA,YAAY,MAAf,EAAuB;AACnB,gCAAG,CAACF,SAAS,CAAV,IAAe,CAAC,CAAnB,EAAsB;AAClBI,sCAAMG,IAAN,CAAW,IAAX,EAAiB,IAAjB,EAAuB,IAAvB;AACH;;AAEDJ,4CAAgBD,SAAhB;;AAEA;AACH;;AAED;AACAA,oCAAY,CAACC,gBAAgB,MAAhB,IAA0B,EAA1B,GAA+BD,YAAY,MAA5C,IAAsD,OAAlE;AACH,qBAxCD,MAyCK,IAAGC,aAAH,EAAkB;AACnB;AACA,4BAAG,CAACH,SAAS,CAAV,IAAe,CAAC,CAAnB,EAAsB;AAClBI,kCAAMG,IAAN,CAAW,IAAX,EAAiB,IAAjB,EAAuB,IAAvB;AACH;AACJ;;AAEDJ,oCAAgB,IAAhB;;AAEA;AACA,wBAAGD,YAAY,IAAf,EAAqB;AACjB,4BAAG,CAACF,SAAS,CAAV,IAAe,CAAlB,EAAqB;AACjB;AACH;;AAEDI,8BAAMG,IAAN,CAAWL,SAAX;AACH,qBAND,MAOK,IAAGA,YAAY,KAAf,EAAsB;AACvB,4BAAG,CAACF,SAAS,CAAV,IAAe,CAAlB,EAAqB;AACjB;AACH;;AAEDI,8BAAMG,IAAN,CACIL,aAAa,GAAb,GAAmB,IADvB,EAEIA,YAAY,IAAZ,GAAmB,IAFvB;AAIH,qBATI,MAUA,IAAGA,YAAY,OAAf,EAAwB;AACzB,4BAAG,CAACF,SAAS,CAAV,IAAe,CAAlB,EAAqB;AACjB;AACH;;AAEDI,8BAAMG,IAAN,CACIL,aAAa,GAAb,GAAmB,IADvB,EAEIA,aAAa,GAAb,GAAmB,IAAnB,GAA0B,IAF9B,EAGIA,YAAY,IAAZ,GAAmB,IAHvB;AAKH,qBAVI,MAWA,IAAGA,YAAY,QAAf,EAAyB;AAC1B,4BAAG,CAACF,SAAS,CAAV,IAAe,CAAlB,EAAqB;AACjB;AACH;;AAEDI,8BAAMG,IAAN,CACIL,aAAa,IAAb,GAAoB,IADxB,EAEIA,aAAa,GAAb,GAAmB,IAAnB,GAA0B,IAF9B,EAGIA,aAAa,GAAb,GAAmB,IAAnB,GAA0B,IAH9B,EAIIA,YAAY,IAAZ,GAAmB,IAJvB;AAMH,qBAXI,MAYA;AACD,8BAAM,IAAIM,KAAJ,CAAU,oBAAV,CAAN;AACH;AACJ;;AAED,uBAAOJ,KAAP;AACH;;AAED,qBAASL,SAAT,CAAmBT,GAAnB,EAAwBO,KAAxB,EAA+BC,GAA/B,EAAoC;AAChCA,sBAAMW,KAAKC,GAAL,CAASpB,IAAIF,MAAb,EAAqBU,GAArB,CAAN;;AAEA,oBAAMa,MAAM,IAAInC,KAAJ,EAAZ;AACA,oBAAI6B,IAAIR,KAAR;;AAEA,uBAAMQ,IAAIP,GAAV,EAAe;AACX,wBAAIc,YAAYtB,IAAIe,CAAJ,CAAhB;AACA,wBAAIH,YAAY,IAAhB;AACA,wBAAIW,mBAAoBD,YAAY,IAAb,GAAqB,CAArB,GAChBA,YAAY,IAAb,GAAqB,CAArB,GACKA,YAAY,IAAb,GAAqB,CAArB,GACI,CAHd;;AAKA,wBAAGP,IAAIQ,gBAAJ,IAAwBf,GAA3B,EAAgC;AAC5B,4BAAIgB,mBAAJ;AAAA,4BAAgBC,kBAAhB;AAAA,4BAA2BC,mBAA3B;AAAA,4BAAuCC,sBAAvC;;AAEA,gCAAOJ,gBAAP;AACI,iCAAK,CAAL;AACI,oCAAGD,YAAY,IAAf,EAAqB;AACjBV,gDAAYU,SAAZ;AACH;;AAED;;AAEJ,iCAAK,CAAL;AACIE,6CAAaxB,IAAIe,IAAI,CAAR,CAAb;;AAEA,oCAAG,CAACS,aAAa,IAAd,MAAwB,IAA3B,EAAiC;AAC7BG,oDAAgB,CAACL,YAAY,IAAb,KAAsB,GAAtB,GAA6BE,aAAa,IAA1D;;AAEA,wCAAGG,gBAAgB,IAAnB,EAAyB;AACrBf,oDAAYe,aAAZ;AACH;AACJ;;AAED;;AAEJ,iCAAK,CAAL;AACIH,6CAAaxB,IAAIe,IAAI,CAAR,CAAb;AACAU,4CAAYzB,IAAIe,IAAI,CAAR,CAAZ;;AAEA,oCAAG,CAACS,aAAa,IAAd,MAAwB,IAAxB,IAAgC,CAACC,YAAY,IAAb,MAAuB,IAA1D,EAAgE;AAC5DE,oDAAgB,CAACL,YAAY,GAAb,KAAqB,GAArB,GAA2B,CAACE,aAAa,IAAd,KAAuB,GAAlD,GAAyDC,YAAY,IAArF;;AAEA,wCAAGE,gBAAgB,KAAhB,KAA0BA,gBAAgB,MAAhB,IAA0BA,gBAAgB,MAApE,CAAH,EAAgF;AAC5Ef,oDAAYe,aAAZ;AACH;AACJ;;AAED;;AAEJ,iCAAK,CAAL;AACIH,6CAAaxB,IAAIe,IAAI,CAAR,CAAb;AACAU,4CAAYzB,IAAIe,IAAI,CAAR,CAAZ;AACAW,6CAAa1B,IAAIe,IAAI,CAAR,CAAb;;AAEA,oCAAG,CAACS,aAAa,IAAd,MAAwB,IAAxB,IAAgC,CAACC,YAAY,IAAb,MAAuB,IAAvD,IAA+D,CAACC,aAAa,IAAd,MAAwB,IAA1F,EAAgG;AAC5FC,oDAAgB,CAACL,YAAY,GAAb,KAAqB,IAArB,GAA4B,CAACE,aAAa,IAAd,KAAuB,GAAnD,GAAyD,CAACC,YAAY,IAAb,KAAsB,GAA/E,GAAsFC,aAAa,IAAnH;;AAEA,wCAAGC,gBAAgB,MAAhB,IAA0BA,gBAAgB,QAA7C,EAAuD;AACnDf,oDAAYe,aAAZ;AACH;AACJ;AA9CT;AAgDH;;AAED,wBAAGf,cAAc,IAAjB,EAAuB;AACnB;AACA;AACAA,oCAAY,MAAZ;AACAW,2CAAmB,CAAnB;AACH,qBALD,MAMK,IAAGX,YAAY,MAAf,EAAuB;AACxB;AACAA,qCAAa,OAAb;AACAS,4BAAIJ,IAAJ,CAASL,cAAc,EAAd,GAAmB,KAAnB,GAA2B,MAApC;AACAA,oCAAY,SAASA,YAAY,KAAjC;AACH;;AAEDS,wBAAIJ,IAAJ,CAASL,SAAT;AACAG,yBAAKQ,gBAAL;AACH;;AAED,uBAAOK,sBAAsBP,GAAtB,CAAP;AACH;;AAED;;AAEA,qBAASQ,IAAT,CAAcC,CAAd,EAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;AACnB,oBAAMjB,IAAIe,EAAEC,CAAF,CAAV;;AAEAD,kBAAEC,CAAF,IAAOD,EAAEE,CAAF,CAAP;AACAF,kBAAEE,CAAF,IAAOjB,CAAP;AACH;;AAED,qBAASa,qBAAT,CAA+BK,UAA/B,EAA2C;AACvC,oBAAMC,MAAMD,WAAWnC,MAAvB;;AAEA,oBAAGoC,OAAO5C,oBAAV,EAAgC;AAC5B,2BAAO6C,OAAOC,YAAP,CAAoBC,KAApB,CAA0BF,MAA1B,EAAkCF,UAAlC,CAAP,CAD4B,CAC0B;AACzD;;AAED;AACA,oBAAIZ,MAAM,EAAV;AACA,oBAAIN,IAAI,CAAR;;AAEA,uBAAMA,IAAImB,GAAV,EAAe;AACXb,2BAAOc,OAAOC,YAAP,CAAoBC,KAApB,CACHF,MADG,EAEHF,WAAWlD,KAAX,CAAiBgC,CAAjB,EAAoBA,KAAKzB,oBAAzB,CAFG,CAAP;AAIH;;AAED,uBAAO+B,GAAP;AACH;AACJ,SAxSyD,EAA9D;;AA0SA;;AAEA,YAAMiB,cAAe,YAAW;AAC5B,gBAAMC,IAAI,IAAIC,WAAJ,CAAgB,CAAC,UAAD,CAAhB,CAAV;AACA,gBAAMV,IAAI,IAAIjD,UAAJ,CAAe0D,EAAEE,MAAjB,EAAyBF,EAAEG,UAA3B,EAAuCH,EAAE7C,UAAzC,CAAV;;AAEA,mBAAOoC,EAAE,CAAF,MAAS,IAAhB;AACH,SALmB,EAApB;;AAOA;;AAEAnC,eAAOgD,IAAP,GAAcL,WAAd;AACA3C,eAAOiD,IAAP,GAAc,CAACN,WAAf;;AAEA,eAAO3C,MAAP;;AAEA;;AAEA,iBAASA,MAAT,CAAgBkD,MAAhB,EAAwBC,iBAAxB,EAA2CC,eAA3C,EAA4D;AACxD,gBAAMC,WAAgB,CAAtB;AACA,gBAAMC,WAAgB,CAAtB;AACA,gBAAMC,WAAgB,CAAtB;AACA,gBAAMC,YAAgB,CAAtB;AACA,gBAAMC,aAAgB,EAAtB;AACA,gBAAMC,YAAgB,EAAtB;;AAEA;;AAEA,gBAAG,CAACR,MAAJ,EAAY;AACRA,yBAAS,EAAT;AACH;;AAED;;AAEA,gBAAMS,cAAgB,OAAOT,MAAP,KAAmB,QAAzC;AACA,gBAAMU,SAAgBD,cAAc,CAAd,GAAkBT,OAAO/C,MAA/C;;AAEA,gBAAM0D,SAAgB,IAAItE,KAAJ,CAAUqE,MAAV,CAAtB;AACA,gBAAME,UAAgB,IAAIvE,KAAJ,CAAUqE,MAAV,CAAtB;;AAEA,gBAAMG,WAAgB,IAAI7E,UAAJ,CAAe,CAAf,CAAtB;;AAEA,gBAAI8E,YAAkB,CAAtB;AAAA,gBAEIC,mBAAkB,IAAI1E,KAAJ,EAFtB;AAAA,gBAGI2E,mBAAkB7E,OAAOW,MAAP,CAAc,IAAd,CAHtB;AAAA,gBAIImE,aAAkB,CAJtB;AAAA,gBAKIC,iBAAkB,KALtB;AAAA,gBAOIC,eAAkB,IAPtB;AAAA,gBAQIC,aAAkB,IARtB;;AAUA;;AAEA,iBAAI,IAAIC,CAAJ,EAAOnD,IAAI,CAAf,EAAkBA,IAAIwC,MAAtB,EAA8B,EAAExC,CAAhC,EAAmC;AAC/BmD,oBAAIZ,cAAc,CAAC,EAAD,EAAKT,MAAL,CAAd,GAA6BA,OAAO9B,CAAP,EAAUoD,KAAV,CAAgB,GAAhB,CAAjC;;AAEA;;AAEA,oBAAMC,OAAOF,EAAEG,KAAF,EAAb;AACA,oBAAMC,UAAUJ,EAAEG,KAAF,EAAhB;;AAEA,oBAAME,OAAOC,UAAUF,QAAQG,OAAR,CAAgB,WAAhB,EAA6B,EAA7B,CAAV,CAAb;AACA,oBAAMC,OAAOC,SAASL,QAAQG,OAAR,CAAgB,KAAhB,EAAuB,EAAvB,CAAT,EAAqC,EAArC,KAA4C,CAAzD;;AAT+B,qCAe3BG,cAAcL,IAAd,EAAoBG,IAApB,CAf2B;AAAA;AAAA,oBAY3B5D,KAZ2B;AAAA,oBAa3B+D,OAb2B;AAAA,oBAc3BC,QAd2B;;AAiB/B,oBAAMC,WAAYR,QAAQvB,WAAWC,QAAnB,CAAD,GAAiC,IAAjC,GAAwC,IAAIpE,UAAJ,CAAegG,QAAQpC,MAAvB,CAAzD;AACA,oBAAMuC,YAAYF,WAAW,IAAIjG,UAAJ,CAAeiG,SAASrC,MAAxB,CAAX,GAA6C,IAA/D;;AAEA;;AAEAe,uBAAOzC,CAAP,IAAY,CAACqD,IAAD,EAAOG,IAAP,EAAazD,KAAb,EAAoB+D,OAApB,EAA6BE,QAA7B,EAAuCD,QAAvC,EAAiDE,SAAjD,CAAZ;;AAEAlB,8BAAchD,KAAd;;AAEA,oBAAG,CAACiD,cAAD,IAAoBQ,QAAQvB,WAAWC,QAAnB,CAAvB,EAAsD;AAClDc,qCAAiB,IAAjB;AACH;AACJ;;AAED5D,mBAAO,CAAP;;AAEA;;AAEA,mBAAO;AACH,oBAAIA,MAAJ,GAAa;AAAE,2BAAOwD,SAAP;AAAmB,iBAD/B;AAEH,oBAAIxD,MAAJ,CAAW8E,KAAX,EAAkB;AAAE9E,2BAAO8E,KAAP;AAAgB,iBAFjC;;AAIHC,0BAJG;AAKHC;AALG,aAAP;;AAQA;;AAEA,qBAAShF,MAAT,CAAgB8E,KAAhB,EAAuB;AACnBA,wBAAQN,SAASM,KAAT,EAAgB,EAAhB,KAAuB,CAA/B;;AAEAnB,6BAAaA,aAAaH,SAAb,GAAyBsB,KAAtC;AACAtB,4BAAYsB,KAAZ;;AAEA,oBAAG,CAAClB,cAAJ,EAAoB;AAChBC,mCAAe,IAAInF,UAAJ,CAAeiF,UAAf,CAAf;AACH;AACJ;;AAED;;AAEA,qBAASoB,IAAT,CAAcE,IAAd,EAAoBC,MAApB,EAA4B;AACxB,oBAAMC,UAAYpG,MAAMoG,OAAN,CAAcF,IAAd,CAAlB;;AAEA,oBAAIG,aAAJ;AAAA,oBACIC,WAAcjC,MADlB;AAAA,oBAEIkC,UAAc9B,SAFlB;;AAIA,oBAAI+B,cAAJ;AACA,oBAAItB,aAAJ;AAAA,oBAAUG,aAAV;AAAA,oBAAgBzD,cAAhB;AAAA,oBAAuB+D,gBAAvB;AAAA,oBAAgCE,iBAAhC;AAAA,oBAA0CD,iBAA1C;AAAA,oBAAoDE,kBAApD;;AAEA,oBAAIW,cAAJ;;AAEA;;AAEAN,yBAASA,UAAUrB,YAAnB;;AAEA;;AAEA,uBAAMwB,UAAN,EAAkB;AACdE,4BAAQlC,OAAOgC,QAAP,CAAR;AADc,iCAEgDE,KAFhD;;AAAA;;AAEbtB,wBAFa;AAEPG,wBAFO;AAEDzD,yBAFC;AAEM+D,2BAFN;AAEeE,4BAFf;AAEyBD,4BAFzB;AAEmCE,6BAFnC;;;AAIdW,4BAAQrC,cAAc8B,IAAd,GAAqBA,KAAKE,UAAUE,QAAV,GAAqBpB,IAA1B,CAA7B;;AAEA;;AAEA,wBAAGG,QAAQvB,WAAWC,QAAnB,CAAH,EAAiC;AAC7B,4BAAGsB,OAAOlB,SAAV,EAAqB;AACjBsC,oCAAQC,KAAKC,SAAL,CAAeF,KAAf,CAAR;AACH;;AAED,4BAAGA,KAAH,EAAU;AACN7E,qCAASgE,SAAS,CAAT,IAAcP,OAAOvB,QAAP,GAAkB3C,WAAWsF,KAAX,EAAkBd,OAAlB,EAA2B/D,KAA3B,EAAkC6E,MAAMjG,UAAxC,CAAlB,GAAwEmF,QAAQjF,KAAR,CAAc+F,KAAd,EAAqB7E,KAArB,CAA/F;;AAEAiE,uCAAWF,OAAX;AACAA,oCAAQiB,KAAR,GAAgBhF,KAAhB;;AAEA;;AAEA,gCAAGwB,WAAH,EAAgB;AACZuC,wCAAQ,CAAR,IAAaG,UAAU,CAAV,CAAb;AACAH,wCAAQ,CAAR,IAAaG,UAAU,CAAV,CAAb;AACH,6BAHD,MAIK;AACDH,wCAAQ,CAAR,IAAaG,UAAU,CAAV,CAAb;AACAH,wCAAQ,CAAR,IAAaG,UAAU,CAAV,CAAb;AACH;AACJ,yBAhBD,MAiBK;AACDD,uCAAWrB,QAAX;AACH;AACJ,qBAzBD,MA0BK;AACD,4BAAGiC,UAAU,IAAV,IAAkBI,MAAMJ,KAAN,CAAlB,IAAkC,CAACK,SAASL,KAAT,CAAnC,IAAsD,OAAOA,KAAP,KAAkB,WAA3E,EAAwF;AACpFd,oCAAQ,CAAR,IAAa,CAAb;AACH,yBAFD,MAGK;AACDA,oCAAQ,CAAR,IAAac,KAAb;;AAEA,gCAAGrD,eAAeuC,QAAQnF,UAAR,GAAqB,CAAvC,EAA0C;AACtCqF,yCAASkB,OAAT;AACH;AACJ;AACJ;;AAED;;AAEA,wBAAGjC,YAAH,EAAiB;AACbuB,+BAAO,CAAP;;AAEA,+BAAMzE,OAAN,EAAe;AACXuE,mCAAOI,SAAP,IAAoBV,SAASQ,MAAT,CAApB;AACH;AACJ,qBAND,MAOK;AACD9B,gCAAQ+B,QAAR,IAAoBT,QAApB;AACAU,mCAAW3E,KAAX;AACH;AACJ;;AAED;;AAEA,oBAAG,CAACkD,YAAJ,EAAkB;AACdqB,6BAASA,UAAUpB,cAAcA,WAAWnE,MAAX,KAAsB2F,OAA9C,GAAwDxB,UAAxD,GAAsEA,aAAa7E,WAAWI,WAAX,CAAuBiG,OAAvB,CAA5F;;AAEAD,+BAAWjC,MAAX;AACAgC,2BAAO5B,SAAP;;AAEA;;AAEA,2BAAM6B,UAAN,EAAkB;AACd,6BAAI,IAAI1D,IAAI2B,QAAQ+B,QAAR,CAAR,EAA2BzE,KAAI,CAA/B,EAAkCmF,IAAKpE,EAAEgE,KAAF,IAAWhE,EAAEhC,MAAxD,EAAiEiB,KAAImF,CAArE,EAAwE,EAAEnF,EAA1E,EAA6E;AACzEsE,mCAAOE,MAAP,IAAiBzD,EAAEf,EAAF,CAAjB;AACH;AACJ;AACJ;;AAED;;AAEA,uBAAOsE,MAAP;AACH;;AAED,qBAASF,MAAT,CAAgBgB,GAAhB,EAAqBhG,MAArB,EAA6BL,MAA7B,EAAqCsG,SAArC,EAAgDf,MAAhD,EAAgH;AAAA,oBAAxDgB,OAAwD,uEAA9CvD,iBAA8C;AAAA,oBAA3BwD,MAA2B,uEAAlB,CAACvD,eAAiB;;AAC5G,oBAAG,CAACQ,MAAJ,EAAY;AACR,wBAAG6C,SAAH,EAAc;AACVA,kCAAUzC,SAAV;AACH;;AAED,2BAAO,IAAP;AACH;;AAED,oBAAG,CAACwC,GAAD,IAAQ,QAAOA,GAAP,yCAAOA,GAAP,OAAgB,QAAxB,IAAoCA,IAAIzG,UAAJ,GAAiBoE,UAAxD,EAAoE;AAChE,2BAAO,KAAK,CAAZ;AACH;;AAED,oBAAG,CAACR,WAAJ,EAAiB;AACb+B,6BAASA,WAAWiB,SAAUD,UAAU,IAAInH,KAAJ,EAAV,GAAwBF,OAAOW,MAAP,CAAc,IAAd,CAAlC,GAA0D0G,UAAUzC,gBAAV,GAA6BC,gBAAlG,CAAT;AACH;;AAED;;AAEA,oBAAI6B,cAAJ;AAAA,oBACIF,WAAWjC,MADf;AAAA,oBAGIa,aAHJ;AAAA,oBAGUG,aAHV;AAAA,oBAGgBzD,cAHhB;AAAA,oBAGuB+D,gBAHvB;AAAA,oBAGgCE,iBAHhC;AAAA,oBAG0CD,iBAH1C;AAAA,oBAGoDE,kBAHpD;;AAKA,oBAAIuB,YAAsBpG,SAASwD,SAAnC;;AAEA,oBAAM6C,iBAAoBD,SAA1B;;AAEA;;AAEA,uBAAMf,UAAN,EAAkB;;AAGd;;AAHc,0DACgDhC,OAAOgC,QAAP,CADhD;;AACbpB,wBADa;AACPG,wBADO;AACDzD,yBADC;AACM+D,2BADN;AACeE,4BADf;AACyBD,4BADzB;AACmCE,6BADnC;AAKd,yBAAI,IAAIjE,MAAI,CAAZ,EAAeA,MAAID,KAAnB,EAA0B,EAAEC,GAA5B,EAA+B;AAC3B,4BAAGwF,aAAazG,MAAhB,EAAwB;AACpB,mCAAO,KAAK,CAAZ;AACH;;AAED,4BAAGgF,QAAH,EAAa;AACTE,sCAAUjE,GAAV,IAAeoF,IAAII,WAAJ,CAAf;AACH,yBAFD,MAGK;AACDxB,qCAAShE,GAAT,IAAcoF,IAAII,WAAJ,CAAd;AACH;AACJ;;AAED;;AAEA,wBAAGhC,QAAQvB,WAAWC,QAAnB,CAAH,EAAiC;AAC7B,4BAAGX,WAAH,EAAgB;AACZ0C,sCAAUiB,OAAV;AACH;;AAED;;AAEA,4BAAMQ,UAAU3B,SAAS,CAAT,CAAhB;;AAEA;;AAEA,4BAAG,CAAC2B,OAAD,IAAYA,WAAW3G,MAA1B,EAAkC;AAC9B4F,oCAAQnB,QAAQvB,WAAWK,SAAnB,IAAgC,IAAhC,GAAuC,EAA/C;AACH,yBAFD,MAGK;AACD,gCAAMqD,UAAUvF,KAAKC,GAAL,CAASyD,QAAQ/E,MAAR,GAAiBgB,KAA1B,EAAiChB,MAAjC,EAAyC2G,OAAzC,CAAhB;AACA,gCAAMzG,MAAMuE,OAAOvB,QAAP,GAAkB5D,WAAWI,WAAX,CAAuBkH,OAAvB,CAAlB,GAAoD7B,OAAhE;;AAEA;;AAEA,iCAAI,IAAI9D,MAAI,CAAZ,EAAeA,MAAI2F,OAAnB,EAA4B,EAAE3F,GAAF,EAAK,EAAEwF,SAAnC,EAA8C;AAC1CvG,oCAAIe,GAAJ,IAASoF,IAAII,SAAJ,CAAT;AACH;;AAED;;AAEAb,oCAAQnB,OAAOvB,QAAP,GAAkBhD,GAAlB,GAAwBA,IAAIH,QAAJ,CAAa,MAAb,EAAqB,CAArB,EAAwB6G,OAAxB,CAAhC;;AAEA,gCAAGnC,OAAOlB,SAAV,EAAqB;AACjB,oCAAI;AACAqC,4CAAQE,KAAKe,KAAL,CAAWjB,KAAX,CAAR;AACH,iCAFD,CAGA,OAAMxB,CAAN,EAAS;AACLwB,4CAAQ,IAAR;AACH;AACJ;AACJ;AACJ,qBArCD,MAsCK;AACD,4BAAGpD,eAAeuC,QAAQnF,UAAR,GAAqB,CAAvC,EAA0C;AACtCqF,qCAASkB,OAAT;AACH;;AAEDP,gCAAQb,QAAQ,CAAR,CAAR;AACH;;AAED;;AAEA,wBAAGvB,WAAH,EAAgB;AACZ+B,iCAASK,KAAT;AACH,qBAFD,MAGK;AACD,4BAAGW,OAAH,EAAY;AACRjC,mCAAOoB,QAAP;AACH;;AAEDH,+BAAOjB,IAAP,IAAesB,KAAf;AACH;AACJ;;AAED,oBAAGU,SAAH,EAAc;AACVA,8BAAUG,YAAYA,SAAZ,GAAwBC,cAAlC;AACH;;AAED;;AAEA,uBAAOnB,MAAP;AACH;;AAED;;AAEA,qBAAST,aAAT,CAAuBL,IAAvB,EAA6BG,IAA7B,EAAmC;AAC/B,oBAAGH,OAAOvB,QAAV,EAAoB;AAChB,2BAAO,CAAC4D,YAAYC,iBAAb,EAAgCzH,WAAWK,eAAX,CAA2B,CAACiF,QAAQ,IAAT,IAAiBkC,YAAYC,iBAAxD,CAAhC,EAA4G,IAAID,WAAJ,CAAgB,CAAhB,CAA5G,CAAP;AACH;;AAED,oBAAGrC,OAAOlB,SAAV,EAAqB;AACjB,2BAAO,CAACuD,YAAYC,iBAAb,EAAgCzH,WAAWK,eAAX,CAA2B,CAACiF,QAAQ,IAAT,IAAiBkC,YAAYC,iBAAxD,CAAhC,EAA4G,IAAID,WAAJ,CAAgB,CAAhB,CAA5G,CAAP;AACH;;AAED,oBAAGrC,OAAOtB,QAAV,EAAoB;AAChB,2BAAO,CAAC2D,YAAYC,iBAAb,EAAgCzH,WAAWK,eAAX,CAA2B,CAACiF,QAAQ,GAAT,IAAgBkC,YAAYC,iBAAvD,CAAhC,EAA2G,IAAID,WAAJ,CAAgB,CAAhB,CAA3G,CAAP;AACH;;AAED,wBAAOrC,IAAP;AACI,yBAAKrB,QAAL;AACI,gCAAOwB,IAAP;AACI,iCAAK,CAAL;AAAQ,uCAAO,CAACoC,UAAUD,iBAAX,EAA8B,IAAIC,SAAJ,CAAc,CAAd,CAA9B,CAAP;AACR,iCAAK,EAAL;AAAS,uCAAO,CAACC,WAAWF,iBAAZ,EAA+B,IAAIE,UAAJ,CAAe,CAAf,CAA/B,CAAP;AACT,iCAAK,EAAL;AAAS,uCAAO,CAACC,WAAWH,iBAAZ,EAA+B,IAAIG,UAAJ,CAAe,CAAf,CAA/B,CAAP;;AAET;AACI,sCAAM,IAAI9F,KAAJ,oBAA2BwD,IAA3B,CAAN;AANR;;AAUJ,yBAAKvB,SAAL;AACI,gCAAOuB,IAAP;AACI,iCAAK,CAAL;AAAQ,uCAAO,CAAC7F,WAAWgI,iBAAZ,EAA+B,IAAIhI,UAAJ,CAAe,CAAf,CAA/B,CAAP;AACR,iCAAK,EAAL;AAAS,uCAAO,CAAC+H,YAAYC,iBAAb,EAAgC,IAAID,WAAJ,CAAgB,CAAhB,CAAhC,CAAP;AACT,iCAAK,EAAL;AAAS,uCAAO,CAACpE,YAAYqE,iBAAb,EAAgC,IAAIrE,WAAJ,CAAgB,CAAhB,CAAhC,CAAP;;AAET;AACI,sCAAM,IAAItB,KAAJ,oBAA2BwD,IAA3B,CAAN;AANR;;AAUJ,yBAAKtB,UAAL;AACI,gCAAOsB,IAAP;AACI,iCAAK,EAAL;AAAS,uCAAO,CAACuC,aAAaJ,iBAAd,EAAiC,IAAII,YAAJ,CAAiB,CAAjB,CAAjC,CAAP;AACT,iCAAK,EAAL;AAAS,uCAAO,CAACC,aAAaL,iBAAd,EAAiC,IAAIK,YAAJ,CAAiB,CAAjB,CAAjC,CAAP;;AAET;AACI,sCAAM,IAAIhG,KAAJ,oBAA2BwD,IAA3B,CAAN;AALR;;AAQJ;AACI,8BAAM,IAAIxD,KAAJ,oBAA2BqD,IAA3B,CAAN;AAjCR;AAmCH;;AAED,qBAASC,SAAT,CAAmBD,IAAnB,EAAyB;AACrB,wBAAOA,IAAP;AACI,yBAAK,GAAL;AACA,yBAAK,KAAL;AACI,+BAAOvB,QAAP;;AAEJ,yBAAK,GAAL;AACA,yBAAK,MAAL;AACI,+BAAOC,WAAWI,SAAlB;;AAEJ,yBAAK,GAAL;AACA,yBAAK,KAAL;AACI,+BAAOJ,QAAP;;AAEJ,yBAAK,GAAL;AACA,yBAAK,KAAL;AACI,+BAAOC,QAAP;;AAEJ,yBAAK,GAAL;AACA,yBAAK,MAAL;AACI,+BAAOC,SAAP;;AAEJ,yBAAK,GAAL;AACA,yBAAK,OAAL;AACI,+BAAOC,UAAP;;AAEJ;AACI,8BAAM,IAAIlC,KAAJ,oBAA2BqD,IAA3B,CAAN;AA1BR;AA4BH;AACJ;;AAED,iBAASlE,UAAT,CAAoB8G,GAApB,EAAyBC,GAAzB,EAA8BjH,MAA9B,EAAsCL,MAAtC,EAA8C;AAC1C,gBAAG,CAACA,MAAJ,EAAY;AACR,uBAAO,CAAP;AACH;;AAED;;AAEA,gBAAMuH,SAASD,IAAItH,MAAnB;AACA,gBAAMwH,SAASH,IAAIrH,MAAnB;;AAEA,gBAAIiB,UAAJ;AAAA,gBAAOwG,UAAP;;AAEA;;AAEA,iBAAIxG,IAAI,CAAR,EAAWA,IAAIjB,MAAf,EAAuB,EAAEiB,CAAzB,EAA4B;AACxBwG,oBAAIxG,IAAIZ,MAAR;;AAEA,oBAAGoH,KAAKF,MAAL,IAAetG,KAAKuG,MAAvB,EAA+B;AAC3B;AACH;;AAEDF,oBAAIG,CAAJ,IAASJ,IAAIpG,CAAJ,CAAT;AACH;;AAED;;AAEA,mBAAOA,CAAP;AACH;AACJ,KAxuBa,EAAd;;AA0uBA;;AAEAnC,WAAO4I,OAAP,GAAiBrI,KAAjB;;AAEA,WAAOA,KAAP;AAAe,CA/vBA,CA+vBE,EA/vBF,CAAf","file":"2pack.js","sourcesContent":["const packer = (function(module) {\r\n                        if(!Uint8Array.prototype.slice) {\r\n                            Object.defineProperty(Uint8Array.prototype, \"slice\", {\r\n                                \"value\": Array.prototype.slice\r\n                            });\r\n                        }\r\n//-----------------------------------------------------\r\n//\r\n// Author: Daeren\r\n// Site: 666.io\r\n//\r\n//-----------------------------------------------------\r\n\r\n\"use strict\";\r\n\r\n//-----------------------------------------------------\r\n\r\nconst bPack = (function() {\r\n    const holyBuffer = (typeof(Buffer) !== \"undefined\" ? Buffer : (function() {\r\n            const MAX_ARGUMENTS_LENGTH = 0x1000;\r\n            const K_MAX_LENGTH = 0x7fffffff;\r\n\r\n            //---------------------]>\r\n\r\n            return (function() {\r\n                const Buffer = function() {};\r\n\r\n                //--------]>\r\n\r\n                Buffer.allocUnsafe = allocUnsafe;\r\n                Buffer.allocUnsafeSlow = allocUnsafe;\r\n                Buffer.byteLength = byteLength;\r\n\r\n                Buffer.prototype = Object.create(null);\r\n                Buffer.prototype.write = write;\r\n                Buffer.prototype.toString = toString;\r\n\r\n                //--------]>\r\n\r\n                return Buffer;\r\n\r\n                //--------]>\r\n\r\n                function allocUnsafe(length) {\r\n                    if(length > K_MAX_LENGTH) {\r\n                        throw new RangeError(\"Invalid typed array length\");\r\n                    }\r\n\r\n                    const buf = new Uint8Array(length);\r\n\r\n                    // buf.__proto__ = Buffer.prototype;\r\n                    buf.write = Buffer.prototype.write;\r\n                    buf.toString = Buffer.prototype.toString;\r\n\r\n                    return buf;\r\n                }\r\n\r\n                function byteLength(string) {\r\n                    return utf8ToBytes(string).length;\r\n                }\r\n\r\n                //----)>\r\n\r\n                function write(string, offset, length) {\r\n                    offset = offset || 0;\r\n                    length = length || this.length;\r\n\r\n                    const remaining = this.length - offset;\r\n\r\n                    if(!length || length > remaining) {\r\n                        length = remaining;\r\n                    }\r\n\r\n                    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);\r\n                }\r\n\r\n                function toString(encoding, start, end) {\r\n                    start = start || 0;\r\n                    end = end || this.length;\r\n\r\n                    return end === 0 ? \"\" : utf8Slice(this, start, end);\r\n                }\r\n            })();\r\n\r\n            //---------------------]>\r\n\r\n            function utf8ToBytes(string, units) {\r\n                units = units || Infinity;\r\n\r\n                const length = string.length;\r\n\r\n                let codePoint;\r\n                let leadSurrogate = null;\r\n                let bytes = new Array();\r\n\r\n                for(let i = 0; i < length; ++i) {\r\n                    codePoint = string.charCodeAt(i);\r\n\r\n                    // is surrogate component\r\n                    if(codePoint > 0xD7FF && codePoint < 0xE000) {\r\n                        // last char was a lead\r\n                        if(!leadSurrogate) {\r\n                            // no lead yet\r\n                            if(codePoint > 0xDBFF) {\r\n                                // unexpected trail\r\n                                if((units -= 3) > -1) {\r\n                                    bytes.push(0xEF, 0xBF, 0xBD);\r\n                                }\r\n\r\n                                continue;\r\n                            }\r\n                            else if(i + 1 === length) {\r\n                                // unpaired lead\r\n                                if((units -= 3) > -1) {\r\n                                    bytes.push(0xEF, 0xBF, 0xBD);\r\n                                }\r\n\r\n                                continue;\r\n                            }\r\n\r\n                            // valid lead\r\n                            leadSurrogate = codePoint;\r\n\r\n                            continue;\r\n                        }\r\n\r\n                        // 2 leads in a row\r\n                        if(codePoint < 0xDC00) {\r\n                            if((units -= 3) > -1) {\r\n                                bytes.push(0xEF, 0xBF, 0xBD);\r\n                            }\r\n\r\n                            leadSurrogate = codePoint;\r\n\r\n                            continue;\r\n                        }\r\n\r\n                        // valid surrogate pair\r\n                        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\r\n                    }\r\n                    else if(leadSurrogate) {\r\n                        // valid bmp char, but last char was a lead\r\n                        if((units -= 3) > -1) {\r\n                            bytes.push(0xEF, 0xBF, 0xBD);\r\n                        }\r\n                    }\r\n\r\n                    leadSurrogate = null;\r\n\r\n                    // encode utf8\r\n                    if(codePoint < 0x80) {\r\n                        if((units -= 1) < 0) {\r\n                            break;\r\n                        }\r\n\r\n                        bytes.push(codePoint);\r\n                    }\r\n                    else if(codePoint < 0x800) {\r\n                        if((units -= 2) < 0) {\r\n                            break;\r\n                        }\r\n\r\n                        bytes.push(\r\n                            codePoint >> 0x6 | 0xC0,\r\n                            codePoint & 0x3F | 0x80\r\n                        );\r\n                    }\r\n                    else if(codePoint < 0x10000) {\r\n                        if((units -= 3) < 0) {\r\n                            break;\r\n                        }\r\n\r\n                        bytes.push(\r\n                            codePoint >> 0xC | 0xE0,\r\n                            codePoint >> 0x6 & 0x3F | 0x80,\r\n                            codePoint & 0x3F | 0x80\r\n                        );\r\n                    }\r\n                    else if(codePoint < 0x110000) {\r\n                        if((units -= 4) < 0) {\r\n                            break;\r\n                        }\r\n\r\n                        bytes.push(\r\n                            codePoint >> 0x12 | 0xF0,\r\n                            codePoint >> 0xC & 0x3F | 0x80,\r\n                            codePoint >> 0x6 & 0x3F | 0x80,\r\n                            codePoint & 0x3F | 0x80\r\n                        );\r\n                    }\r\n                    else {\r\n                        throw new Error(\"Invalid code point\");\r\n                    }\r\n                }\r\n\r\n                return bytes;\r\n            }\r\n\r\n            function utf8Slice(buf, start, end) {\r\n                end = Math.min(buf.length, end);\r\n\r\n                const res = new Array();\r\n                let i = start;\r\n\r\n                while(i < end) {\r\n                    let firstByte = buf[i];\r\n                    let codePoint = null;\r\n                    let bytesPerSequence = (firstByte > 0xEF) ? 4\r\n                        : (firstByte > 0xDF) ? 3\r\n                            : (firstByte > 0xBF) ? 2\r\n                                : 1;\r\n\r\n                    if(i + bytesPerSequence <= end) {\r\n                        let secondByte, thirdByte, fourthByte, tempCodePoint;\r\n\r\n                        switch(bytesPerSequence) {\r\n                            case 1:\r\n                                if(firstByte < 0x80) {\r\n                                    codePoint = firstByte;\r\n                                }\r\n\r\n                                break;\r\n\r\n                            case 2:\r\n                                secondByte = buf[i + 1];\r\n\r\n                                if((secondByte & 0xC0) === 0x80) {\r\n                                    tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\r\n\r\n                                    if(tempCodePoint > 0x7F) {\r\n                                        codePoint = tempCodePoint;\r\n                                    }\r\n                                }\r\n\r\n                                break;\r\n\r\n                            case 3:\r\n                                secondByte = buf[i + 1];\r\n                                thirdByte = buf[i + 2];\r\n\r\n                                if((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n                                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\r\n\r\n                                    if(tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n                                        codePoint = tempCodePoint;\r\n                                    }\r\n                                }\r\n\r\n                                break;\r\n\r\n                            case 4:\r\n                                secondByte = buf[i + 1];\r\n                                thirdByte = buf[i + 2];\r\n                                fourthByte = buf[i + 3];\r\n\r\n                                if((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n                                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\r\n\r\n                                    if(tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n                                        codePoint = tempCodePoint;\r\n                                    }\r\n                                }\r\n                        }\r\n                    }\r\n\r\n                    if(codePoint === null) {\r\n                        // we did not generate a valid codePoint so insert a\r\n                        // replacement char (U+FFFD) and advance only 1 byte\r\n                        codePoint = 0xFFFD;\r\n                        bytesPerSequence = 1;\r\n                    }\r\n                    else if(codePoint > 0xFFFF) {\r\n                        // encode to utf16 (surrogate pair dance)\r\n                        codePoint -= 0x10000;\r\n                        res.push(codePoint >>> 10 & 0x3FF | 0xD800);\r\n                        codePoint = 0xDC00 | codePoint & 0x3FF;\r\n                    }\r\n\r\n                    res.push(codePoint);\r\n                    i += bytesPerSequence;\r\n                }\r\n\r\n                return decodeCodePointsArray(res);\r\n            }\r\n\r\n            //--------)>\r\n\r\n            function swap(b, n, m) {\r\n                const i = b[n];\r\n\r\n                b[n] = b[m];\r\n                b[m] = i;\r\n            }\r\n\r\n            function decodeCodePointsArray(codePoints) {\r\n                const len = codePoints.length;\r\n\r\n                if(len <= MAX_ARGUMENTS_LENGTH) {\r\n                    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\r\n                }\r\n\r\n                // Decode in chunks to avoid \"call stack size exceeded\".\r\n                let res = \"\";\r\n                let i = 0;\r\n\r\n                while(i < len) {\r\n                    res += String.fromCharCode.apply(\r\n                        String,\r\n                        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\r\n                    );\r\n                }\r\n\r\n                return res;\r\n            }\r\n        })());\r\n\r\n    //-------------------------]>\r\n\r\n    const isBigEndian = (function() {\r\n        const a = new Uint32Array([0x12345678]);\r\n        const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\r\n\r\n        return b[0] === 0x12;\r\n    })();\r\n\r\n    //-------------------------]>\r\n\r\n    create.isBE = isBigEndian;\r\n    create.isLE = !isBigEndian;\r\n\r\n    return create;\r\n\r\n    //-------------------------]>\r\n\r\n    function create(schema, dataHolderAsArray, holderRecreated) {\r\n        const TYPE_BIN      = 1;\r\n        const TYPE_STR      = 2;\r\n        const TYPE_INT      = 4;\r\n        const TYPE_UINT     = 8;\r\n        const TYPE_FLOAT    = 16;\r\n        const TYPE_JSON     = 32;\r\n\r\n        //-----------------]>\r\n\r\n        if(!schema) {\r\n            schema = [];\r\n        }\r\n\r\n        //-----------------]>\r\n\r\n        const isPrimitive   = typeof(schema) === \"string\";\r\n        const schLen        = isPrimitive ? 1 : schema.length;\r\n\r\n        const fields        = new Array(schLen);\r\n        const buffers       = new Array(schLen);\r\n\r\n        const zeroUI16      = new Uint8Array(2);\r\n\r\n        let pktOffset       = 0,\r\n\r\n            pktDataHolderArr= new Array(),\r\n            pktDataHolderObj= Object.create(null),\r\n            pktMinSize      = 0,\r\n            pktDynamicSize  = false,\r\n\r\n            pktBufStrict    = null,\r\n            pktBufPack      = null;\r\n\r\n        //-----------------]>\r\n\r\n        for(let e, i = 0; i < schLen; ++i) {\r\n            e = isPrimitive ? [\"\", schema] : schema[i].split(\":\");\r\n\r\n            //---------]>\r\n\r\n            const name = e.shift();\r\n            const subType = e.shift();\r\n\r\n            const type = getTypeId(subType.replace(/[\\d\\[\\]]/g, \"\"));\r\n            const size = parseInt(subType.replace(/\\D/g, \"\"), 10) || 0;\r\n\r\n            const [\r\n                bytes,\r\n                bufType,\r\n                bufAType\r\n            ] = buildTypedBuf(type, size);\r\n\r\n            const bufBytes = (type & (TYPE_BIN | TYPE_STR)) ? null : new Uint8Array(bufType.buffer);\r\n            const bufABytes = bufAType ? new Uint8Array(bufAType.buffer) : null;\r\n\r\n            //---------]>\r\n\r\n            fields[i] = [name, type, bytes, bufType, bufBytes, bufAType, bufABytes];\r\n\r\n            pktMinSize += bytes;\r\n\r\n            if(!pktDynamicSize && (type & (TYPE_BIN | TYPE_STR))) {\r\n                pktDynamicSize = true;\r\n            }\r\n        }\r\n\r\n        offset(0);\r\n\r\n        //-----------------]>\r\n\r\n        return {\r\n            get offset() { return pktOffset; },\r\n            set offset(value) { offset(value); },\r\n\r\n            pack,\r\n            unpack\r\n        };\r\n\r\n        //-----------------]>\r\n\r\n        function offset(value) {\r\n            value = parseInt(value, 10) || 0;\r\n\r\n            pktMinSize = pktMinSize - pktOffset + value;\r\n            pktOffset = value;\r\n\r\n            if(!pktDynamicSize) {\r\n                pktBufStrict = new Uint8Array(pktMinSize);\r\n            }\r\n        }\r\n\r\n        //------)>\r\n\r\n        function pack(data, target) {\r\n            const isArray   = Array.isArray(data);\r\n\r\n            let tIdx,\r\n                fieldIdx    = schLen,\r\n                pktSize     = pktOffset;\r\n\r\n            let field;\r\n            let name, type, bytes, bufType, bufBytes, bufAType, bufABytes;\r\n\r\n            let input;\r\n\r\n            //--------]>\r\n\r\n            target = target || pktBufStrict;\r\n\r\n            //--------]>\r\n\r\n            while(fieldIdx--) {\r\n                field = fields[fieldIdx];\r\n                [name, type, bytes, bufType, bufBytes, bufAType, bufABytes] = field;\r\n\r\n                input = isPrimitive ? data : data[isArray ? fieldIdx : name];\r\n\r\n                //------]>\r\n\r\n                if(type & (TYPE_BIN | TYPE_STR)) {\r\n                    if(type & TYPE_JSON) {\r\n                        input = JSON.stringify(input);\r\n                    }\r\n\r\n                    if(input) {\r\n                        bytes += bufAType[0] = type & TYPE_BIN ? blitBuffer(input, bufType, bytes, input.byteLength) : bufType.write(input, bytes);\r\n\r\n                        bufBytes = bufType;\r\n                        bufType._blen = bytes;\r\n\r\n                        //-----]>\r\n\r\n                        if(isBigEndian) {\r\n                            bufType[0] = bufABytes[1];\r\n                            bufType[1] = bufABytes[0];\r\n                        }\r\n                        else {\r\n                            bufType[0] = bufABytes[0];\r\n                            bufType[1] = bufABytes[1];\r\n                        }\r\n                    }\r\n                    else {\r\n                        bufBytes = zeroUI16;\r\n                    }\r\n                }\r\n                else {\r\n                    if(input === null || isNaN(input) || !isFinite(input) || typeof(input) === \"undefined\") {\r\n                        bufType[0] = 0;\r\n                    }\r\n                    else {\r\n                        bufType[0] = input;\r\n\r\n                        if(isBigEndian && bufType.byteLength > 1) {\r\n                            bufBytes.reverse();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                //------]>\r\n\r\n                if(pktBufStrict) {\r\n                    tIdx = 0;\r\n\r\n                    while(bytes--) {\r\n                        target[pktSize++] = bufBytes[tIdx++];\r\n                    }\r\n                }\r\n                else {\r\n                    buffers[fieldIdx] = bufBytes;\r\n                    pktSize += bytes;\r\n                }\r\n            }\r\n\r\n            //--------]>\r\n\r\n            if(!pktBufStrict) {\r\n                target = target || pktBufPack && pktBufPack.length === pktSize ? pktBufPack : (pktBufPack = holyBuffer.allocUnsafe(pktSize));\r\n\r\n                fieldIdx = schLen;\r\n                tIdx = pktOffset;\r\n\r\n                //--------]>\r\n\r\n                while(fieldIdx--) {\r\n                    for(let b = buffers[fieldIdx], i = 0, l = (b._blen || b.length); i < l; ++i) {\r\n                        target[tIdx++] = b[i];\r\n                    }\r\n                }\r\n            }\r\n\r\n            //--------]>\r\n\r\n            return target;\r\n        }\r\n\r\n        function unpack(bin, offset, length, cbEndInfo, target, asArray = dataHolderAsArray, asCopy = !holderRecreated) {\r\n            if(!schLen) {\r\n                if(cbEndInfo) {\r\n                    cbEndInfo(pktOffset);\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            if(!bin || typeof(bin) !== \"object\" || bin.byteLength < pktMinSize) {\r\n                return void(0);\r\n            }\r\n\r\n            if(!isPrimitive) {\r\n                target = target || (asCopy ? (asArray ? new Array() : Object.create(null)) : (asArray ? pktDataHolderArr : pktDataHolderObj));\r\n            }\r\n\r\n            //--------]>\r\n\r\n            let field,\r\n                fieldIdx = schLen,\r\n\r\n                name, type, bytes, bufType, bufBytes, bufAType, bufABytes;\r\n\r\n            let curOffset           = offset + pktOffset;\r\n\r\n            const pktOffsetStart    = curOffset;\r\n\r\n            //--------]>\r\n\r\n            while(fieldIdx--) {\r\n                [name, type, bytes, bufType, bufBytes, bufAType, bufABytes] = fields[fieldIdx];\r\n\r\n                //------]>\r\n\r\n                for(let i = 0; i < bytes; ++i) {\r\n                    if(curOffset >= length) {\r\n                        return void(0);\r\n                    }\r\n\r\n                    if(bufAType) {\r\n                        bufABytes[i] = bin[curOffset++];\r\n                    }\r\n                    else {\r\n                        bufBytes[i] = bin[curOffset++];\r\n                    }\r\n                }\r\n\r\n                //------]>\r\n\r\n                if(type & (TYPE_BIN | TYPE_STR)) {\r\n                    if(isBigEndian) {\r\n                        bufABytes.reverse();\r\n                    }\r\n\r\n                    //--------]>\r\n\r\n                    const byteLen = bufAType[0];\r\n\r\n                    //--------]>\r\n\r\n                    if(!byteLen || byteLen >= length) {\r\n                        field = type & (TYPE_BIN | TYPE_JSON) ? null : \"\";\r\n                    }\r\n                    else {\r\n                        const needMem = Math.min(bufType.length - bytes, length, byteLen);\r\n                        const buf = type & TYPE_BIN ? holyBuffer.allocUnsafe(needMem) : bufType;\r\n\r\n                        //-------]>\r\n\r\n                        for(let i = 0; i < needMem; ++i, ++curOffset) {\r\n                            buf[i] = bin[curOffset];\r\n                        }\r\n\r\n                        //-------]>\r\n\r\n                        field = type & TYPE_BIN ? buf : buf.toString(\"utf8\", 0, needMem);\r\n\r\n                        if(type & TYPE_JSON) {\r\n                            try {\r\n                                field = JSON.parse(field);\r\n                            }\r\n                            catch(e) {\r\n                                field = null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if(isBigEndian && bufType.byteLength > 1) {\r\n                        bufBytes.reverse();\r\n                    }\r\n\r\n                    field = bufType[0];\r\n                }\r\n\r\n                //------]>\r\n\r\n                if(isPrimitive) {\r\n                    target = field;\r\n                }\r\n                else {\r\n                    if(asArray) {\r\n                        name = fieldIdx;\r\n                    }\r\n\r\n                    target[name] = field;\r\n                }\r\n            }\r\n\r\n            if(cbEndInfo) {\r\n                cbEndInfo(curOffset + curOffset - pktOffsetStart);\r\n            }\r\n\r\n            //--------]>\r\n\r\n            return target;\r\n        }\r\n\r\n        //-----------------]>\r\n\r\n        function buildTypedBuf(type, size) {\r\n            if(type & TYPE_BIN) {\r\n                return [Uint16Array.BYTES_PER_ELEMENT, holyBuffer.allocUnsafeSlow((size || 1024) + Uint16Array.BYTES_PER_ELEMENT), new Uint16Array(1)];\r\n            }\r\n\r\n            if(type & TYPE_JSON) {\r\n                return [Uint16Array.BYTES_PER_ELEMENT, holyBuffer.allocUnsafeSlow((size || 8192) + Uint16Array.BYTES_PER_ELEMENT), new Uint16Array(1)];\r\n            }\r\n\r\n            if(type & TYPE_STR) {\r\n                return [Uint16Array.BYTES_PER_ELEMENT, holyBuffer.allocUnsafeSlow((size || 256) + Uint16Array.BYTES_PER_ELEMENT), new Uint16Array(1)];\r\n            }\r\n\r\n            switch(type) {\r\n                case TYPE_INT:\r\n                    switch(size) {\r\n                        case 8: return [Int8Array.BYTES_PER_ELEMENT, new Int8Array(1)];\r\n                        case 16: return [Int16Array.BYTES_PER_ELEMENT, new Int16Array(1)];\r\n                        case 32: return [Int32Array.BYTES_PER_ELEMENT, new Int32Array(1)];\r\n\r\n                        default:\r\n                            throw new Error(`Unknown size: ${size}`);\r\n                    }\r\n\r\n\r\n                case TYPE_UINT:\r\n                    switch(size) {\r\n                        case 8: return [Uint8Array.BYTES_PER_ELEMENT, new Uint8Array(1)];\r\n                        case 16: return [Uint16Array.BYTES_PER_ELEMENT, new Uint16Array(1)];\r\n                        case 32: return [Uint32Array.BYTES_PER_ELEMENT, new Uint32Array(1)];\r\n\r\n                        default:\r\n                            throw new Error(`Unknown size: ${size}`);\r\n                    }\r\n\r\n\r\n                case TYPE_FLOAT:\r\n                    switch(size) {\r\n                        case 32: return [Float32Array.BYTES_PER_ELEMENT, new Float32Array(1)];\r\n                        case 64: return [Float64Array.BYTES_PER_ELEMENT, new Float64Array(1)];\r\n\r\n                        default:\r\n                            throw new Error(`Unknown size: ${size}`);\r\n                    }\r\n\r\n                default:\r\n                    throw new Error(`Unknown type: ${type}`);\r\n            }\r\n        }\r\n\r\n        function getTypeId(type) {\r\n            switch(type) {\r\n                case \"b\":\r\n                case \"bin\":\r\n                    return TYPE_BIN;\r\n\r\n                case \"j\":\r\n                case \"json\":\r\n                    return TYPE_STR | TYPE_JSON;\r\n\r\n                case \"s\":\r\n                case \"str\":\r\n                    return TYPE_STR;\r\n\r\n                case \"i\":\r\n                case \"int\":\r\n                    return TYPE_INT;\r\n\r\n                case \"u\":\r\n                case \"uint\":\r\n                    return TYPE_UINT;\r\n\r\n                case \"f\":\r\n                case \"float\":\r\n                    return TYPE_FLOAT;\r\n\r\n                default:\r\n                    throw new Error(`Unknown type: ${type}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    function blitBuffer(src, dst, offset, length) {\r\n        if(!length) {\r\n            return 0;\r\n        }\r\n\r\n        //-------]>\r\n\r\n        const dstLen = dst.length;\r\n        const srcLen = src.length;\r\n\r\n        let i, t;\r\n\r\n        //-------]>\r\n\r\n        for(i = 0; i < length; ++i) {\r\n            t = i + offset;\r\n\r\n            if(t >= dstLen || i >= srcLen) {\r\n                break;\r\n            }\r\n\r\n            dst[t] = src[i];\r\n        }\r\n\r\n        //-------]>\r\n\r\n        return i;\r\n    }\r\n})();\r\n\r\n//-----------------------------------------------------\r\n\r\nmodule.exports = bPack;\r\n\r\nreturn bPack; })({});"]}