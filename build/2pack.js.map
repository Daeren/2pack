{"version":3,"sources":["2packES6.js"],"names":["packer","module","Uint8Array","prototype","slice","Object","defineProperty","value","begin","end","byteLength","Math","floor","min","max","ArrayBuffer","len","result","resultBytes","sourceBytes","bPack","XBuffer","Buffer","MAX_ARGUMENTS_LENGTH","K_MAX_LENGTH","allocUnsafe","allocUnsafeSlow","length","RangeError","buf","write","toString","string","offset","remaining","blitBuffer","utf8ToBytes","encoding","start","utf8Slice","units","Infinity","codePoint","leadSurrogate","bytes","Array","i","charCodeAt","push","Error","res","firstByte","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","String","fromCharCode","apply","isBigEndian","a","Uint32Array","b","buffer","byteOffset","create","isBE","isLE","schema","holderRecreated","dataHolderAsArray","TYPE_BIN","TYPE_STR","TYPE_INT","TYPE_UINT","TYPE_FLOAT","TYPE_JSON","isArray","schemaContNames","some","e","split","schemaDontContNames","int64size","BigInt64Array","BYTES_PER_ELEMENT","isPrimitive","schLen","fields","zeroUI16","pktDataBuf","pktOffset","pktMinSize","pktMaxSize","pktDataHolderArr","pktDataHolderObj","reverse","subType","name","type","getTypeId","replace","size","parseInt","buildTypedBuf","bufType","bufAType","bufBytes","bufABytes","minSize","maxSize","pack","unpack","data","target","outTg","fieldIdx","pktSize","input","field","JSON","stringify","zeroValue","BigInt","isNaN","isFinite","tIdx","bin","cbEndInfo","asCopy","asArray","curOffset","pktOffsetStart","byteLen","from","call","parse","Uint16Array","Int8Array","Int16Array","Int32Array","BigUint64Array","Float32Array","Float64Array","src","dst","dstLen","srcLen","t","exports"],"mappings":"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","file":"2pack.js","sourcesContent":["const packer = (function(module) {\r\n//-----------------------------------------------------\r\n//\r\n// Author: Daeren\r\n// Site: 666.io\r\n//\r\n//-----------------------------------------------------\r\n\r\n\"use strict\";\r\n\r\n//-----------------------------------------------------\r\n\r\nif(!Uint8Array.prototype.slice) {\r\n    Object.defineProperty(Uint8Array.prototype, \"slice\", {\r\n        value(begin, end) {\r\n            //If 'begin' is unspecified, Chrome assumes 0, so we do the same\r\n            if(begin === void 0) {\r\n                begin = 0;\r\n            }\r\n\r\n            //If 'end' is unspecified, the new ArrayBuffer contains all\r\n            //bytes from 'begin' to the end of this ArrayBuffer.\r\n            if(end === void 0) {\r\n                end = this.byteLength;\r\n            }\r\n\r\n            //Chrome converts the values to integers via flooring\r\n            begin = Math.floor(begin);\r\n            end = Math.floor(end);\r\n\r\n            //If either 'begin' or 'end' is negative, it refers to an\r\n            //index from the end of the array, as opposed to from the beginning.\r\n            if(begin < 0) {\r\n                begin += this.byteLength;\r\n            }\r\n\r\n            if (end < 0) {\r\n                end += this.byteLength;\r\n            }\r\n\r\n            //The range specified by the 'begin' and 'end' values is clamped to the\r\n            //valid index range for the current array.\r\n            begin = Math.min(Math.max(0, begin), this.byteLength);\r\n            end = Math.min(Math.max(0, end), this.byteLength);\r\n\r\n            //If the computed length of the new ArrayBuffer would be negative, it\r\n            //is clamped to zero.\r\n            if(end - begin <= 0) {\r\n                return new ArrayBuffer(0);\r\n            }\r\n\r\n            let len = end - begin;\r\n\r\n            const result = new ArrayBuffer(len);\r\n            const resultBytes = new Uint8Array(result);\r\n            const sourceBytes = new Uint8Array(this, begin, len);\r\n\r\n\r\n            while(len--) {\r\n                resultBytes[len] = sourceBytes[len];\r\n            }\r\n\r\n            // some problems with IE11\r\n            //resultBytes.set(sourceBytes);\r\n\r\n            return resultBytes;\r\n        }\r\n    });\r\n}\r\n\r\n//-----------------------------------------------------\r\n\r\nconst bPack = (function() {\r\n    const XBuffer = (typeof(Buffer) !== \"undefined\" ? Buffer : (function() {\r\n            const MAX_ARGUMENTS_LENGTH = 0x1000;\r\n            const K_MAX_LENGTH = 0x7fffffff;\r\n\r\n            //---------------------]>\r\n\r\n            return (function() {\r\n                const Buffer = function() {};\r\n\r\n                //--------]>\r\n\r\n                Buffer.allocUnsafe = allocUnsafe;\r\n                Buffer.allocUnsafeSlow = allocUnsafe;\r\n\r\n                //--------]>\r\n\r\n                return Buffer;\r\n\r\n                //--------]>\r\n\r\n                function allocUnsafe(length) {\r\n                    if(length > K_MAX_LENGTH) {\r\n                        throw new RangeError(\"Invalid typed array length\");\r\n                    }\r\n\r\n                    const buf = new Uint8Array(length);\r\n\r\n                    buf.write = write;\r\n                    buf.toString = toString;\r\n\r\n                    return buf;\r\n                }\r\n\r\n                //----)>\r\n\r\n                function write(string, offset, length) {\r\n                    offset = offset || 0;\r\n                    length = length || this.length;\r\n\r\n                    const remaining = this.length - offset;\r\n\r\n                    if(!length || length > remaining) {\r\n                        length = remaining;\r\n                    }\r\n\r\n                    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);\r\n                }\r\n\r\n                function toString(encoding, start, end) {\r\n                    start = start || 0;\r\n                    end = end || this.length;\r\n\r\n                    return end === 0 ? \"\" : utf8Slice(this, start, end);\r\n                }\r\n            })();\r\n\r\n            //---------------------]>\r\n\r\n            function utf8ToBytes(string, units) {\r\n                units = units || Infinity;\r\n\r\n                const length = string.length;\r\n\r\n                let codePoint;\r\n                let leadSurrogate = null;\r\n                let bytes = new Array();\r\n\r\n                for(let i = 0; i < length; ++i) {\r\n                    codePoint = string.charCodeAt(i);\r\n\r\n                    // is surrogate component\r\n                    if(codePoint > 0xD7FF && codePoint < 0xE000) {\r\n                        // last char was a lead\r\n                        if(!leadSurrogate) {\r\n                            // no lead yet\r\n                            if(codePoint > 0xDBFF) {\r\n                                // unexpected trail\r\n                                if((units -= 3) > -1) {\r\n                                    bytes.push(0xEF, 0xBF, 0xBD);\r\n                                }\r\n\r\n                                continue;\r\n                            }\r\n                            else if(i + 1 === length) {\r\n                                // unpaired lead\r\n                                if((units -= 3) > -1) {\r\n                                    bytes.push(0xEF, 0xBF, 0xBD);\r\n                                }\r\n\r\n                                continue;\r\n                            }\r\n\r\n                            // valid lead\r\n                            leadSurrogate = codePoint;\r\n\r\n                            continue;\r\n                        }\r\n\r\n                        // 2 leads in a row\r\n                        if(codePoint < 0xDC00) {\r\n                            if((units -= 3) > -1) {\r\n                                bytes.push(0xEF, 0xBF, 0xBD);\r\n                            }\r\n\r\n                            leadSurrogate = codePoint;\r\n\r\n                            continue;\r\n                        }\r\n\r\n                        // valid surrogate pair\r\n                        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\r\n                    }\r\n                    else if(leadSurrogate) {\r\n                        // valid bmp char, but last char was a lead\r\n                        if((units -= 3) > -1) {\r\n                            bytes.push(0xEF, 0xBF, 0xBD);\r\n                        }\r\n                    }\r\n\r\n                    leadSurrogate = null;\r\n\r\n                    // encode utf8\r\n                    if(codePoint < 0x80) {\r\n                        if((units -= 1) < 0) {\r\n                            break;\r\n                        }\r\n\r\n                        bytes.push(codePoint);\r\n                    }\r\n                    else if(codePoint < 0x800) {\r\n                        if((units -= 2) < 0) {\r\n                            break;\r\n                        }\r\n\r\n                        bytes.push(\r\n                            codePoint >> 0x6 | 0xC0,\r\n                            codePoint & 0x3F | 0x80\r\n                        );\r\n                    }\r\n                    else if(codePoint < 0x10000) {\r\n                        if((units -= 3) < 0) {\r\n                            break;\r\n                        }\r\n\r\n                        bytes.push(\r\n                            codePoint >> 0xC | 0xE0,\r\n                            codePoint >> 0x6 & 0x3F | 0x80,\r\n                            codePoint & 0x3F | 0x80\r\n                        );\r\n                    }\r\n                    else if(codePoint < 0x110000) {\r\n                        if((units -= 4) < 0) {\r\n                            break;\r\n                        }\r\n\r\n                        bytes.push(\r\n                            codePoint >> 0x12 | 0xF0,\r\n                            codePoint >> 0xC & 0x3F | 0x80,\r\n                            codePoint >> 0x6 & 0x3F | 0x80,\r\n                            codePoint & 0x3F | 0x80\r\n                        );\r\n                    }\r\n                    else {\r\n                        throw new Error(\"Invalid code point\");\r\n                    }\r\n                }\r\n\r\n                return bytes;\r\n            }\r\n\r\n            function utf8Slice(buf, start, end) {\r\n                end = Math.min(buf.length, end);\r\n\r\n                const res = new Array();\r\n                let i = start;\r\n\r\n                while(i < end) {\r\n                    let firstByte = buf[i];\r\n                    let codePoint = null;\r\n                    let bytesPerSequence = (firstByte > 0xEF) ? 4\r\n                        : (firstByte > 0xDF) ? 3\r\n                            : (firstByte > 0xBF) ? 2\r\n                                : 1;\r\n\r\n                    if(i + bytesPerSequence <= end) {\r\n                        let secondByte, thirdByte, fourthByte, tempCodePoint;\r\n\r\n                        switch(bytesPerSequence) {\r\n                            case 1:\r\n                                if(firstByte < 0x80) {\r\n                                    codePoint = firstByte;\r\n                                }\r\n\r\n                                break;\r\n\r\n                            case 2:\r\n                                secondByte = buf[i + 1];\r\n\r\n                                if((secondByte & 0xC0) === 0x80) {\r\n                                    tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\r\n\r\n                                    if(tempCodePoint > 0x7F) {\r\n                                        codePoint = tempCodePoint;\r\n                                    }\r\n                                }\r\n\r\n                                break;\r\n\r\n                            case 3:\r\n                                secondByte = buf[i + 1];\r\n                                thirdByte = buf[i + 2];\r\n\r\n                                if((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n                                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\r\n\r\n                                    if(tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n                                        codePoint = tempCodePoint;\r\n                                    }\r\n                                }\r\n\r\n                                break;\r\n\r\n                            case 4:\r\n                                secondByte = buf[i + 1];\r\n                                thirdByte = buf[i + 2];\r\n                                fourthByte = buf[i + 3];\r\n\r\n                                if((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n                                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\r\n\r\n                                    if(tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n                                        codePoint = tempCodePoint;\r\n                                    }\r\n                                }\r\n                        }\r\n                    }\r\n\r\n                    if(codePoint === null) {\r\n                        // we did not generate a valid codePoint so insert a\r\n                        // replacement char (U+FFFD) and advance only 1 byte\r\n                        codePoint = 0xFFFD;\r\n                        bytesPerSequence = 1;\r\n                    }\r\n                    else if(codePoint > 0xFFFF) {\r\n                        // encode to utf16 (surrogate pair dance)\r\n                        codePoint -= 0x10000;\r\n                        res.push(codePoint >>> 10 & 0x3FF | 0xD800);\r\n                        codePoint = 0xDC00 | codePoint & 0x3FF;\r\n                    }\r\n\r\n                    res.push(codePoint);\r\n                    i += bytesPerSequence;\r\n                }\r\n\r\n                return decodeCodePointsArray(res);\r\n            }\r\n\r\n            //--------)>\r\n\r\n            function decodeCodePointsArray(codePoints) {\r\n                const len = codePoints.length;\r\n\r\n                if(len <= MAX_ARGUMENTS_LENGTH) {\r\n                    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\r\n                }\r\n\r\n                // Decode in chunks to avoid \"call stack size exceeded\".\r\n                let res = \"\";\r\n                let i = 0;\r\n\r\n                while(i < len) {\r\n                    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\r\n                }\r\n\r\n                return res;\r\n            }\r\n        })());\r\n\r\n    const isBigEndian = (function() {\r\n        const a = new Uint32Array([0x12345678]);\r\n        const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\r\n\r\n        return b[0] === 0x12;\r\n    })();\r\n\r\n    //-------------------------]>\r\n\r\n    create.isBE = isBigEndian;\r\n    create.isLE = !isBigEndian;\r\n\r\n    //-------------------------]>\r\n\r\n    return create;\r\n\r\n    //-------------------------]>\r\n\r\n    function create(schema, holderRecreated = false, dataHolderAsArray = false) {\r\n        const TYPE_BIN      = 1;\r\n        const TYPE_STR      = 2;\r\n        const TYPE_INT      = 4;\r\n        const TYPE_UINT     = 8;\r\n        const TYPE_FLOAT    = 16;\r\n        const TYPE_JSON     = 32;\r\n\r\n        //-----------------]>\r\n\r\n        if(schema === null) {\r\n            schema = [];\r\n        }\r\n\r\n        if(!schema || !Array.isArray(schema) && typeof(schema) !== \"string\") {\r\n            throw new Error(\"Invalid schema\");\r\n        }\r\n\r\n        //-----------------]>\r\n\r\n        const schemaContNames = Array.isArray(schema) ? schema.some((e) => e.split(\":\").length >= 2) : false;\r\n        const schemaDontContNames = Array.isArray(schema) ? schema.some((e) => e.split(\":\").length < 2) : true;\r\n\r\n        //-----------------]>\r\n\r\n        if(schemaContNames && schemaDontContNames) {\r\n            throw new Error(\"A schema has mixed names/types\");\r\n        }\r\n\r\n        if(schemaDontContNames) {\r\n            dataHolderAsArray = true;\r\n        }\r\n\r\n        //-----------------]>\r\n\r\n        const int64size     = typeof(BigInt64Array) !== \"undefined\" ? BigInt64Array.BYTES_PER_ELEMENT : 0;\r\n\r\n        const isPrimitive   = typeof(schema) === \"string\";\r\n        const schLen        = isPrimitive ? 1 : schema.length;\r\n\r\n        const fields        = new Array(schLen);\r\n        const zeroUI16      = new Uint8Array(2);\r\n\r\n        //---------)>\r\n\r\n        let pktDataBuf      = null;\r\n        let pktOffset       = 0;\r\n        let pktMinSize      = 0;\r\n        let pktMaxSize      = 0;\r\n\r\n        let pktDataHolderArr = new Array();\r\n        let pktDataHolderObj = Object.create(null);\r\n\r\n        //-----------------]>\r\n\r\n        for(let i = 0; i < schLen; ++i) {\r\n            const [subType, name] = isPrimitive ? [schema, \"\"] : schema[i].split(\":\").reverse();\r\n\r\n            const type = getTypeId(subType.replace(/[\\d\\[\\]]/g, \"\"));\r\n            const size = parseInt(subType.replace(/\\D/g, \"\"), 10) || 0;\r\n\r\n            const [\r\n                bytes,   // BYTES_PER_ELEMENT\r\n                bufType, // dataView\r\n                bufAType // dataSizeView\r\n            ] = buildTypedBuf(type, size);\r\n\r\n            const bufBytes = ((type & TYPE_STR) || (type & TYPE_BIN)) ? null : new Uint8Array(bufType.buffer);\r\n            const bufABytes = bufAType ? new Uint8Array(bufAType.buffer) : null;\r\n\r\n            //---------]>\r\n\r\n            fields[i] = [name, type, bytes, bufType, bufBytes, bufAType, bufABytes];\r\n\r\n            pktMinSize += bytes;\r\n            pktMaxSize += bufType.byteLength;\r\n        }\r\n\r\n        offset(0);\r\n\r\n        //-----------------]>\r\n\r\n        return {\r\n            get minSize() { return pktMinSize; },\r\n            get maxSize() { return pktMaxSize; },\r\n\r\n            get offset() { return pktOffset; },\r\n            set offset(value) { offset(value); },\r\n\r\n            pack,\r\n            unpack\r\n        };\r\n\r\n        //-----------------]>\r\n\r\n        function offset(value) {\r\n            value = parseInt(value, 10) || 0;\r\n\r\n            pktMinSize = (pktMinSize - pktOffset) + value;\r\n            pktMaxSize = (pktMaxSize - pktOffset) + value;\r\n            pktOffset = value;\r\n\r\n            pktDataBuf = XBuffer.allocUnsafeSlow(pktMaxSize);\r\n        }\r\n\r\n        //------)>\r\n\r\n        function pack(data, target) {\r\n            const isArray = Array.isArray(data);\r\n            const outTg = !!target;\r\n\r\n            let fieldIdx = schLen;\r\n            let pktSize = pktOffset;\r\n\r\n            let input = data;\r\n\r\n            let field;\r\n            let name, type, bytes, bufType, bufBytes, bufAType, bufABytes;\r\n\r\n            //--------]>\r\n\r\n            target = target || pktDataBuf;\r\n\r\n            //--------]>\r\n\r\n            while(fieldIdx--) {\r\n                field = fields[fieldIdx];\r\n                [name, type, bytes, bufType, bufBytes, bufAType, bufABytes] = field;\r\n\r\n                //------]>\r\n\r\n                if(!isPrimitive && data) {\r\n                    input = data[isArray ? fieldIdx : name];\r\n                }\r\n\r\n                //------]>\r\n\r\n                if((type & TYPE_STR) || (type & TYPE_BIN)) {\r\n                    if(type & TYPE_JSON) {\r\n                        input = JSON.stringify(input);\r\n                    }\r\n\r\n                    if(input) {\r\n                        bytes += bufAType[0] = type & TYPE_BIN ? blitBuffer(input, target, pktSize + bytes, bufType.byteLength - bytes) : target.write(input, pktSize + bytes, bufType.byteLength - bytes);\r\n\r\n                        if(isBigEndian) {\r\n                            target[pktSize] = bufABytes[1];\r\n                            target[pktSize + 1] = bufABytes[0];\r\n                        }\r\n                        else {\r\n                            target[pktSize] = bufABytes[0];\r\n                            target[pktSize + 1] = bufABytes[1];\r\n                        }\r\n\r\n                        pktSize += bytes;\r\n\r\n                    }\r\n                    else {\r\n                        target[pktSize] = 0;\r\n                        target[pktSize + 1] = 0;\r\n\r\n                        pktSize += 2;\r\n                    }\r\n                }\r\n                else {\r\n                    let zeroValue = 0;\r\n\r\n                    if(bytes === int64size) {\r\n                        zeroValue = BigInt(\"0\");\r\n                    }\r\n\r\n                    if(input == null || typeof(input) !== \"bigint\" && (isNaN(input) || !isFinite(input))) {\r\n                        bufType[0] = zeroValue;\r\n                    }\r\n                    else {\r\n                        bufType[0] = input;\r\n\r\n                        if(isBigEndian && bufType.byteLength > 1) {\r\n                            bufBytes.reverse();\r\n                        }\r\n                    }\r\n\r\n                    let tIdx = 0;\r\n\r\n                    while(tIdx < bytes) {\r\n                        target[pktSize] = bufBytes[tIdx];\r\n\r\n                        ++pktSize;\r\n                        ++tIdx;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //--------]>\r\n\r\n            return !outTg && pktSize < pktMaxSize ? target.slice(0, pktSize) : target;\r\n        }\r\n\r\n        function unpack(bin, offset, length, cbEndInfo, target, asCopy = !holderRecreated, asArray = dataHolderAsArray) {\r\n            if(!schLen) {\r\n                if(cbEndInfo) {\r\n                    cbEndInfo(pktOffset);\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            if(!bin || typeof(bin) !== \"object\" || bin.byteLength < pktMinSize) {\r\n                return void(0);\r\n            }\r\n\r\n            if(!isPrimitive) {\r\n                target = target || (asCopy ? (asArray ? new Array() : Object.create(null)) : (asArray ? pktDataHolderArr : pktDataHolderObj));\r\n            }\r\n\r\n            //--------]>\r\n\r\n            let fieldIdx = schLen;\r\n            let curOffset = offset + pktOffset;\r\n\r\n            const pktOffsetStart = curOffset;\r\n\r\n            //--------]>\r\n\r\n            while(fieldIdx--) {\r\n                let field;\r\n                let [name, type, bytes, bufType, bufBytes, bufAType, bufABytes] = fields[fieldIdx];\r\n\r\n                //------]>\r\n\r\n                for(let i = 0; i < bytes; ++i) {\r\n                    if(curOffset >= length) {\r\n                        return void(0);\r\n                    }\r\n\r\n                    if(bufAType) {\r\n                        bufABytes[i] = bin[curOffset];\r\n                    }\r\n                    else {\r\n                        bufBytes[i] = bin[curOffset];\r\n                    }\r\n\r\n                    ++curOffset;\r\n                }\r\n\r\n                //------]>\r\n\r\n                if((type & TYPE_STR) || (type & TYPE_BIN)) {\r\n                    if(isBigEndian) {\r\n                        bufABytes.reverse();\r\n                    }\r\n\r\n                    //--------]>\r\n\r\n                    const byteLen = bufAType[0];\r\n\r\n                    //--------]>\r\n\r\n                    if(!byteLen) {\r\n                        field = (type & TYPE_BIN) || (type & TYPE_JSON) ? null : \"\";\r\n                    }\r\n                    else if(byteLen >= length || byteLen > bufType.byteLength) {\r\n                        return void(0);\r\n                    }\r\n                    else {\r\n                        if(type & TYPE_BIN) {\r\n                            const buf = XBuffer.allocUnsafeSlow(byteLen);\r\n\r\n                            for(let i = 0; i < byteLen; ++i, ++curOffset) {\r\n                                buf[i] = bin[curOffset];\r\n                            }\r\n\r\n                            field = buf;\r\n                        }\r\n                        else {\r\n                            if(bin instanceof(XBuffer)) {\r\n                                field = bin.toString(\"utf8\", curOffset, curOffset + byteLen);\r\n                            }\r\n                            else if(XBuffer.from) {\r\n                                field = XBuffer.from(bin).toString(\"utf8\", curOffset, curOffset + byteLen);\r\n                            }\r\n                            else {\r\n                                field = bufType.toString.call(bin, \"utf8\", curOffset, curOffset + byteLen);\r\n                            }\r\n\r\n                            curOffset += byteLen;\r\n                        }\r\n\r\n                        if(type & TYPE_JSON) {\r\n                            try {\r\n                                field = JSON.parse(field);\r\n                            }\r\n                            catch(e) {\r\n                                field = null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if(isBigEndian && bufType.byteLength > 1) {\r\n                        bufBytes.reverse();\r\n                    }\r\n\r\n                    field = bufType[0];\r\n                }\r\n\r\n                //------]>\r\n\r\n                if(isPrimitive) {\r\n                    target = field;\r\n                }\r\n                else {\r\n                    if(asArray) {\r\n                        name = fieldIdx;\r\n                    }\r\n\r\n                    target[name] = field;\r\n                }\r\n            }\r\n\r\n            if(cbEndInfo) {\r\n                cbEndInfo(pktOffset + curOffset - pktOffsetStart);\r\n            }\r\n\r\n            //--------]>\r\n\r\n            return target;\r\n        }\r\n\r\n        //-----------------]>\r\n\r\n        function buildTypedBuf(type, size) {\r\n            if(type & TYPE_BIN) {\r\n                return [Uint16Array.BYTES_PER_ELEMENT, XBuffer.allocUnsafeSlow((size || 1024) + Uint16Array.BYTES_PER_ELEMENT), new Uint16Array(1)];\r\n            }\r\n\r\n            if(type & TYPE_JSON) {\r\n                return [Uint16Array.BYTES_PER_ELEMENT, XBuffer.allocUnsafeSlow((size || 8192) + Uint16Array.BYTES_PER_ELEMENT), new Uint16Array(1)];\r\n            }\r\n\r\n            if(type & TYPE_STR) {\r\n                return [Uint16Array.BYTES_PER_ELEMENT, XBuffer.allocUnsafeSlow((size || 256) + Uint16Array.BYTES_PER_ELEMENT), new Uint16Array(1)];\r\n            }\r\n\r\n            switch(type) {\r\n                case TYPE_INT:\r\n                    switch(size) {\r\n                        case 8: return [Int8Array.BYTES_PER_ELEMENT, new Int8Array(1)];\r\n                        case 16: return [Int16Array.BYTES_PER_ELEMENT, new Int16Array(1)];\r\n                        case 32: return [Int32Array.BYTES_PER_ELEMENT, new Int32Array(1)];\r\n                        case 64: return [BigInt64Array.BYTES_PER_ELEMENT, new BigInt64Array(1)];\r\n\r\n                        default:\r\n                            throw new Error(`Unknown size: ${size} | ${type}`);\r\n                    }\r\n\r\n\r\n                case TYPE_UINT:\r\n                    switch(size) {\r\n                        case 8: return [Uint8Array.BYTES_PER_ELEMENT, new Uint8Array(1)];\r\n                        case 16: return [Uint16Array.BYTES_PER_ELEMENT, new Uint16Array(1)];\r\n                        case 32: return [Uint32Array.BYTES_PER_ELEMENT, new Uint32Array(1)];\r\n                        case 64: return [BigUint64Array.BYTES_PER_ELEMENT, new BigUint64Array(1)];\r\n\r\n                        default:\r\n                            throw new Error(`Unknown size: ${size} | ${type}`);\r\n                    }\r\n\r\n\r\n                case TYPE_FLOAT:\r\n                    switch(size) {\r\n                        case 32: return [Float32Array.BYTES_PER_ELEMENT, new Float32Array(1)];\r\n                        case 64: return [Float64Array.BYTES_PER_ELEMENT, new Float64Array(1)];\r\n\r\n                        default:\r\n                            throw new Error(`Unknown size: ${size} | ${type}`);\r\n                    }\r\n\r\n                default:\r\n                    throw new Error(`Unknown type: ${type} | ${type}`);\r\n            }\r\n        }\r\n\r\n        function getTypeId(type) {\r\n            switch(type) {\r\n                case \"b\":\r\n                case \"bin\":\r\n                    return TYPE_BIN;\r\n\r\n                case \"j\":\r\n                case \"json\":\r\n                    return TYPE_STR | TYPE_JSON;\r\n\r\n                case \"s\":\r\n                case \"str\":\r\n                    return TYPE_STR;\r\n\r\n                case \"i\":\r\n                case \"int\":\r\n                    return TYPE_INT;\r\n\r\n                case \"u\":\r\n                case \"uint\":\r\n                    return TYPE_UINT;\r\n\r\n                case \"f\":\r\n                case \"float\":\r\n                    return TYPE_FLOAT;\r\n\r\n                default:\r\n                    throw new Error(`Unknown type: ${type}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    function blitBuffer(src, dst, offset, length) {\r\n        if(!length) {\r\n            return 0;\r\n        }\r\n\r\n        //-------]>\r\n\r\n        const dstLen = dst.length;\r\n        const srcLen = src.length;\r\n\r\n        let i, t;\r\n\r\n        //-------]>\r\n\r\n        for(i = 0; i < length; ++i) {\r\n            t = i + offset;\r\n\r\n            if(t >= dstLen || i >= srcLen) {\r\n                break;\r\n            }\r\n\r\n            dst[t] = src[i];\r\n        }\r\n\r\n        //-------]>\r\n\r\n        return i;\r\n    }\r\n})();\r\n\r\n//-----------------------------------------------------\r\n\r\nmodule.exports = bPack;\r\n\r\nreturn module.exports; })({});"]}