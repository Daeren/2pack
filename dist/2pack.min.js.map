{"version":3,"file":"2pack.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAgB,OAAID,IAEpBD,EAAa,OAAIC,IARnB,CASGK,MAAM,KACT,O,+qCCVA,IACUC,EAsRAC,EAvRJC,EAA8B,oBAAZC,OAA0BA,QACxCH,EAAuB,KAKrB,WACJ,IAAMG,EAAS,aASf,OALAA,EAAOC,YAAcA,EACrBD,EAAOE,gBAAkBD,EAIlBD,EAIP,SAASC,EAAYE,GACjB,GAAGA,EAnBU,WAoBT,MAAM,IAAIC,WAAW,8BAGzB,IAAMC,EAAM,IAAIC,WAAWH,GAK3B,OAHAE,EAAIE,MAAQA,EACZF,EAAIG,SAAWA,EAERH,EAKX,SAASE,EAAME,EAAQC,EAAQP,GAC3BO,EAASA,GAAU,EACnBP,EAASA,GAAUQ,KAAKR,OAExB,IAAMS,EAAYD,KAAKR,OAASO,EAMhC,QAJIP,GAAUA,EAASS,KACnBT,EAASS,GAGNC,EAaf,SAAqBJ,EAAQK,GACzBA,EAAQA,GAASC,EAAAA,EAQjB,IANA,IAEIC,EAFEb,EAASM,EAAON,OAGlBc,EAAgB,KAChBC,EAAQ,IAAIC,MAERC,EAAI,EAAGA,EAAIjB,IAAUiB,EAAG,CAI5B,IAHAJ,EAAYP,EAAOY,WAAWD,IAGf,OAAUJ,EAAY,MAAQ,CAEzC,IAAIC,EAAe,CAEf,GAAGD,EAAY,MAAQ,EAEfF,GAAS,IAAM,GACfI,EAAMI,KAAK,IAAM,IAAM,KAG3B,SAEC,GAAGF,EAAI,IAAMjB,EAAQ,EAElBW,GAAS,IAAM,GACfI,EAAMI,KAAK,IAAM,IAAM,KAG3B,SAIJL,EAAgBD,EAEhB,SAIJ,GAAGA,EAAY,MAAQ,EACfF,GAAS,IAAM,GACfI,EAAMI,KAAK,IAAM,IAAM,KAG3BL,EAAgBD,EAEhB,SAIJA,EAAkE,OAArDC,EAAgB,OAAU,GAAKD,EAAY,YAEpDC,IAEAH,GAAS,IAAM,GACfI,EAAMI,KAAK,IAAM,IAAM,KAO/B,GAHAL,EAAgB,KAGbD,EAAY,IAAM,CACjB,IAAIF,GAAS,GAAK,EACd,MAGJI,EAAMI,KAAKN,QAEV,GAAGA,EAAY,KAAO,CACvB,IAAIF,GAAS,GAAK,EACd,MAGJI,EAAMI,KACFN,GAAa,EAAM,IACP,GAAZA,EAAmB,UAGtB,GAAGA,EAAY,MAAS,CACzB,IAAIF,GAAS,GAAK,EACd,MAGJI,EAAMI,KACFN,GAAa,GAAM,IACnBA,GAAa,EAAM,GAAO,IACd,GAAZA,EAAmB,SAGtB,MAAGA,EAAY,SAahB,MAAM,IAAIO,MAAM,sBAZhB,IAAIT,GAAS,GAAK,EACd,MAGJI,EAAMI,KACFN,GAAa,GAAO,IACpBA,GAAa,GAAM,GAAO,IAC1BA,GAAa,EAAM,GAAO,IACd,GAAZA,EAAmB,MAQ/B,OAAOE,EA1HeM,CAAYf,EAAQE,KAAKR,OAASO,GAASC,KAAMD,EAAQP,GAG/E,SAASK,EAASiB,EAAUC,EAAOC,GAI/B,OAHAD,EAAQA,GAAS,EAGF,KAFfC,EAAMA,GAAOhB,KAAKR,QAEC,GAsH3B,SAAmBE,EAAKqB,EAAOC,GAC3BA,EAAMC,KAAKC,IAAIxB,EAAIF,OAAQwB,GAK3B,IAHA,IAAMG,EAAM,IAAIX,MACZC,EAAIM,EAEFN,EAAIO,GAAK,CACX,IAAII,EAAY1B,EAAIe,GAChBJ,EAAY,KACZgB,EAAoBD,EAAY,IAAQ,EACrCA,EAAY,IAAQ,EAChBA,EAAY,IAAQ,EACjB,EAEd,GAAGX,EAAIY,GAAoBL,EAAK,CAC5B,IAAIM,OAAU,EAAEC,OAAS,EAAEC,OAAU,EAAEC,OAAa,EAEpD,OAAOJ,GACH,KAAK,EACED,EAAY,MACXf,EAAYe,GAGhB,MAEJ,KAAK,EAG0B,MAAV,KAFjBE,EAAa5B,EAAIe,EAAI,OAGjBgB,GAA6B,GAAZL,IAAqB,EAAoB,GAAbE,GAE1B,MACfjB,EAAYoB,GAIpB,MAEJ,KAAK,EACDH,EAAa5B,EAAIe,EAAI,GACrBc,EAAY7B,EAAIe,EAAI,GAEO,MAAV,IAAba,IAAsD,MAAV,IAAZC,KAChCE,GAA6B,GAAZL,IAAoB,IAAoB,GAAbE,IAAsB,EAAmB,GAAZC,GAEtD,OAAUE,EAAgB,OAAUA,EAAgB,SACnEpB,EAAYoB,GAIpB,MAEJ,KAAK,EACDH,EAAa5B,EAAIe,EAAI,GACrBc,EAAY7B,EAAIe,EAAI,GACpBe,EAAa9B,EAAIe,EAAI,GAEM,MAAV,IAAba,IAAsD,MAAV,IAAZC,IAAsD,MAAV,IAAbC,KAC/DC,GAA6B,GAAZL,IAAoB,IAAqB,GAAbE,IAAsB,IAAmB,GAAZC,IAAqB,EAAoB,GAAbC,GAEnF,OAAUC,EAAgB,UACzCpB,EAAYoB,IAMf,OAAdpB,GAGCA,EAAY,MACZgB,EAAmB,GAEfhB,EAAY,QAEhBA,GAAa,MACbc,EAAIR,KAAKN,IAAc,GAAK,KAAQ,OACpCA,EAAY,MAAqB,KAAZA,GAGzBc,EAAIR,KAAKN,GACTI,GAAKY,EAGT,OAKJ,SAA+BK,GAC3B,IAAMC,EAAMD,EAAWlC,OAEvB,GAAGmC,GAAOzC,EACN,OAAO0C,OAAOC,aAAaC,MAAMF,OAAQF,GAO7C,IAHA,IAAIP,EAAM,GACNV,EAAI,EAEFA,EAAIkB,GACNR,GAAOS,OAAOC,aAAaC,MAAMF,OAAQF,EAAWK,MAAMtB,EAAGA,GAAKvB,IAGtE,OAAOiC,EApBAa,CAAsBb,GA1MDc,CAAUjC,KAAMe,EAAOC,IA9C/C,IAgRNkB,GACI/C,EAAI,IAAIgD,YAAY,CAAC,YAGX,KAFN,IAAIxC,WAAWR,EAAEiD,OAAQjD,EAAEkD,WAAYlD,EAAEmD,YAE1C,IAocb,SAASpC,EAAWqC,EAAKC,EAAKzC,EAAQP,GAClC,IAAIA,EACA,OAAO,EAKX,IAGIiB,EAAGgC,EAHDC,EAASF,EAAIhD,OACbmD,EAASJ,EAAI/C,OAMnB,IAAIiB,EAAI,EAAGA,EAAIjB,MACXiD,EAAIhC,EAAIV,IAEA2C,GAAUjC,GAAKkC,KAHFlC,EAOrB+B,EAAIC,GAAKF,EAAI9B,GAKjB,OAAOA,EAzdX3B,EAAOD,QAAU,SAAS+D,GACtB,IAKMC,EAAgB,GAQtB,GAJc,OAAXD,IACCA,EAAS,KAGTA,IAAWpC,MAAMsC,QAAQF,IAA8B,iBAAZA,EAC3C,MAAM,IAAIhC,MAAM,kBAKpB,IAAMmC,IAAkBvC,MAAMsC,QAAQF,IAAUA,EAAOI,MAAK,SAACC,GAAD,OAAOA,EAAEC,MAAM,KAAK1D,QAAU,KACpF2D,GAAsB3C,MAAMsC,QAAQF,IAAUA,EAAOI,MAAK,SAACC,GAAD,OAAOA,EAAEC,MAAM,KAAK1D,OAAS,KAI7F,GAAGuD,GAAmBI,EAClB,MAAM,IAAIvC,MAAM,kCAwBpB,IAnBA,IAAMwC,EAA0C,oBAAnBC,cAAiCA,cAAcC,kBAAoB,EAE1FC,EAAmC,iBAAZX,EACvBY,EAAgBD,EAAc,EAAIX,EAAOpD,OAEzCiE,EAAgB,IAAIjD,MAAMgD,GAI5BE,EAAkB,KAClBC,EAAkB,EAClBC,EAAkB,EAClBC,EAAkB,EAElBC,EAAmB,IAAItD,MACvBuD,EAAmBC,OAAOC,OAAO,MAI7BxD,EAAI,EAAGA,EAAI+C,IAAU/C,EAAG,CAC5B,QAAwB8C,EAAc,CAACX,EAAQ,IAAMA,EAAOnC,GAAGyC,MAAM,KAAKgB,UAA1E,GAAOC,EAAP,KAAgBC,EAAhB,KAEMC,EAAOC,EAAUH,EAAQI,QAAQ,YAAa,KAGpD,IAIIC,EAAcH,EANLI,SAASN,EAAQI,QAAQ,MAAO,IAAK,KAAO,GAEzD,GACIhE,EADJ,KAEImE,EAFJ,KAGIC,EAHJ,KAMMC,EA5DY,MA4DCP,IA7DD,MA6DmCA,GAAiC,KAAO,IAAI1E,WAAW+E,EAAQtC,QAC9GyC,EAAYF,EAAW,IAAIhF,WAAWgF,EAASvC,QAAU,KAI/DqB,EAAOhD,GAAK,CAAC2D,EAAMC,EAAM9D,EAAOmE,EAASE,EAAUD,EAAUE,GAE7DjB,GAAcrD,EACdsD,GAAca,EAAQpC,WAO1B,OAJAvC,EAAO,GAIA,CACC+E,cAAY,OAAOlB,GACnBmB,cAAY,OAAOlB,GAEnB9D,aAAW,OAAO4D,GAClB5D,WAAOiF,GAASjF,EAAOiF,IAE3BC,KAwBJ,SAAcC,EAAMC,GAChB,IASIf,EAAMC,EAAM9D,EAAOmE,EAASE,EAAUD,EAAUE,EAT9C/B,EAAUtC,MAAMsC,QAAQoC,GACxBE,IAAUD,EAEZE,EAAW7B,EACX8B,EAAU3B,EAEV4B,EAAQL,EAWZ,IAJAC,EAASA,GAAUzB,EAIb2B,KAAY,SACN5B,EAAO4B,GADD,GAYd,GAVCjB,EAFa,KAEPC,EAFO,KAED9D,EAFC,KAEMmE,EAFN,KAEeE,EAFf,KAEyBD,EAFzB,KAEmCE,EAFnC,MAMVtB,GAAe2B,IACfK,EAAQL,EAAKpC,EAAUuC,EAAWjB,IAnIxB,MAwIVC,IAzIU,MAyIwBA,IAC9BA,EAAOxB,KAAeA,IACtB0C,EAAQC,KAAKC,UAAUF,IAGxBA,GACChF,GAASoE,EAAS,GA/IZ,MA+ImBN,GACnBnE,EAAWqF,EAAOJ,EAAQG,EAAU/E,EAAOmE,EAAQpC,WAAa/B,GAChE4E,EAAOvF,MAAM2F,EAAOD,EAAU/E,EAAOmE,EAAQpC,WAAa/B,GAE7D2B,GACCiD,EAAOG,GAAWT,EAAU,GAC5BM,EAAOG,EAAU,GAAKT,EAAU,KAGhCM,EAAOG,GAAWT,EAAU,GAC5BM,EAAOG,EAAU,GAAKT,EAAU,IAGpCS,GAAW/E,IAIX4E,EAAOG,GAAW,EAClBH,EAAOG,EAAU,GAAK,EAEtBA,GAAW,OAGd,CACD,IAAII,EAAY,EAEbnF,IAAU6C,IACTsC,EAAYC,OAAO,MAGX,MAATJ,GAAmC,iBAAXA,IAAwBK,MAAML,KAAWM,SAASN,IACzEb,EAAQ,GAAKgB,GAGbhB,EAAQ,GAAKa,EAEVrD,GAAewC,EAAQpC,WAAa,GACnCsC,EAASV,WAMjB,IAFA,IAAI4B,EAAO,EAELA,EAAOvF,GACT4E,EAAOG,GAAWV,EAASkB,KAEzBR,IACAQ,GAOd,OAAQV,GAASE,EAAUzB,EAAasB,EAAOpD,MAAM,EAAGuD,GAAWH,GAjHnEY,OA+HJ,SAAgBC,EAAKjG,EAAQP,EAAQyG,EAAWd,GAAwC,IAAhCe,IAAgC,yDAAjBC,EAAiB,wDACpF,IAAI3C,EAKA,OAJGyC,GACCA,EAAUtC,GAGP,KAKX,GAAIqC,GAAuB,WAAhB,EAAOA,MAAqBA,EAAI1D,WAAasB,GAAxD,CAIGT,IACCgD,GAAU,GAGV5C,IACA4B,EAASA,IAAWe,EAAUC,EAAU,IAAI3F,MAAUwD,OAAOC,OAAO,MAAUkC,EAAUrC,EAAmBC,IAY/G,IAPA,IAAIsB,EAAW7B,EACX4C,EAAYrG,EAAS4D,EAEnB0C,EAAiBD,EAIjBf,KAAY,CAMd,IALA,IAAIiB,OAAK,EACT,IAAkE7C,EAAO4B,GAAzE,GAAKjB,EAAL,KAAWC,EAAX,KAAiB9D,EAAjB,KAAwBmE,EAAxB,KAAiCE,EAAjC,KAA2CD,EAA3C,KAAqDE,EAArD,KAIQpE,EAAI,EAAGA,EAAIF,IAASE,EAAG,CAC3B,GAAG2F,GAAa5G,EACZ,OAGDmF,EACCE,EAAUpE,GAAKuF,EAAII,GAGnBxB,EAASnE,GAAKuF,EAAII,KAGpBA,EAKN,GAzQc,MAyQV/B,IA1QU,MA0QwBA,GAA+B,CAC9DnC,GACC2C,EAAUX,UAKd,IAAMqC,EAAU5B,EAAS,GAIzB,GAAI4B,EAGC,IAAGA,GAAW/G,GAAU+G,EAAU7B,EAAQpC,WAC3C,OAGA,GA5RM,MA4RF+B,GAA+B,CAG/B,IAFA,IAAM3E,EAAMN,EAAQG,gBAAgBgH,GAE5B9F,EAAI,EAAGA,EAAI8F,IAAW9F,IAAK2F,EAC/B1G,EAAIe,GAAKuF,EAAII,GAGjBE,EAAQ5G,OAIJ4G,EADDN,aAAe5G,EACN4G,EAAInG,SAAS,OAAQuG,EAAWA,EAAYG,GAEhDnH,EAAQoH,KACJpH,EAAQoH,KAAKR,GAAKnG,SAAS,OAAQuG,EAAWA,EAAYG,GAEtC,oBAAjBE,aACF,IAAIA,aAAeC,OAAOV,EAAIjE,MAAMqE,EAAWA,EAAYG,GAASnE,QAGrEsC,EAAQ7E,SAAS8G,KAAKX,EAAK,OAAQI,EAAWA,EAAYG,GAGtEH,GAAaG,EAGjB,IAAIlC,EAAOxB,KAAeA,EACtB,IACIyD,EAAQd,KAAKoB,MAAMN,GAEvB,MAAMrD,GACFqD,EAAQ,WArChBA,EAtRM,MAsRGjC,KAAkCA,EAAOxB,KAAeA,EAAY,KAAO,QA2CrFX,GAAewC,EAAQpC,WAAa,GACnCsC,EAASV,UAGboC,EAAQ5B,EAAQ,GAKjBnB,EACC4B,EAASmB,GAGNH,IACC/B,EAAOiB,GAGXF,EAAOf,GAAQkC,GAUvB,OANGL,GACCA,EAAUtC,EAAYyC,EAAYC,GAK/BlB,KAnQX,SAASpF,EAAOiF,GACZA,EAAQP,SAASO,EAAO,KAAO,EAE/BpB,EAAcA,EAAaD,EAAaqB,EACxCnB,EAAcA,EAAaF,EAAaqB,EACxCrB,EAAYqB,EAEZtB,EAAatE,EAAQG,gBAAgBsE,GAiQzC,SAASW,EAAcH,EAAMwC,GACzB,GAlWkB,MAkWdxC,GACA,MAAO,CAACyC,YAAYxD,kBAAmBlE,EAAQG,iBAAiBsH,GAAQ,MAAQC,YAAYxD,mBAAoB,IAAIwD,YAAY,IAGpI,IAAIzC,EAAOxB,KAAeA,EACtB,MAAO,CAACiE,YAAYxD,kBAAmBlE,EAAQG,iBAAiBsH,GAAQ,MAAQC,YAAYxD,mBAAoB,IAAIwD,YAAY,IAGpI,GAzWkB,MAyWdzC,GACA,MAAO,CAACyC,YAAYxD,kBAAmBlE,EAAQG,iBAAiBsH,GAAQ,KAAOC,YAAYxD,mBAAoB,IAAIwD,YAAY,IAGnI,OAAOzC,GACH,KA7Wc,EA8WV,OAAOwC,GACH,KAAK,EAAG,MAAO,CAACE,UAAUzD,kBAAmB,IAAIyD,UAAU,IAC3D,KAAK,GAAI,MAAO,CAACC,WAAW1D,kBAAmB,IAAI0D,WAAW,IAC9D,KAAK,GAAI,MAAO,CAACC,WAAW3D,kBAAmB,IAAI2D,WAAW,IAC9D,KAAK,GAAI,MAAO,CAAC5D,cAAcC,kBAAmB,IAAID,cAAc,IAEpE,QACI,MAAM,IAAIzC,MAAJ,wBAA2BiG,EAA3B,cAAqCxC,IAIvD,KAxXc,EAyXV,OAAOwC,GACH,KAAK,EAAG,MAAO,CAAClH,WAAW2D,kBAAmB,IAAI3D,WAAW,IAC7D,KAAK,GAAI,MAAO,CAACmH,YAAYxD,kBAAmB,IAAIwD,YAAY,IAChE,KAAK,GAAI,MAAO,CAAC3E,YAAYmB,kBAAmB,IAAInB,YAAY,IAChE,KAAK,GAAI,MAAO,CAAC+E,eAAe5D,kBAAmB,IAAI4D,eAAe,IAEtE,QACI,MAAM,IAAItG,MAAJ,wBAA2BiG,EAA3B,cAAqCxC,IAIvD,KAnYc,GAoYV,OAAOwC,GACH,KAAK,GAAI,MAAO,CAACM,aAAa7D,kBAAmB,IAAI6D,aAAa,IAClE,KAAK,GAAI,MAAO,CAACC,aAAa9D,kBAAmB,IAAI8D,aAAa,IAElE,QACI,MAAM,IAAIxG,MAAJ,wBAA2BiG,EAA3B,cAAqCxC,IAGvD,QACI,MAAM,IAAIzD,MAAJ,wBAA2ByD,EAA3B,cAAqCA,KAIvD,SAASC,EAAUD,GACf,OAAOA,GACH,IAAK,IACL,IAAK,MACD,OAzZU,EA2Zd,IAAK,IACL,IAAK,OACD,OAAOgD,GAEX,IAAK,IACL,IAAK,MACD,OAhaU,EAkad,IAAK,IACL,IAAK,MACD,OAnaU,EAqad,IAAK,IACL,IAAK,OACD,OAtaU,EAwad,IAAK,IACL,IAAK,QACD,OAzaU,GA2ad,QACI,MAAM,IAAIzG,MAAJ,wBAA2ByD,OAOjDL,OAAOsD,OAAOxI,EAAOD,QAAS,CACtB0I,WAAS,OAAOrF,GAChBsF,WAAS,OAAQtF,OCxtBrBuF,EAA2B,GCE3BC,EDCJ,SAASC,EAAoBC,GAE5B,IAAIC,EAAeJ,EAAyBG,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAahJ,QAGrB,IAAIC,EAAS2I,EAAyBG,GAAY,CAGjD/I,QAAS,IAOV,OAHAkJ,EAAoBH,GAAU9I,EAAQA,EAAOD,QAAS8I,GAG/C7I,EAAOD,QClBW8I,CAAoB,K,QDF1CF,ECEAC","sources":["webpack://packer/webpack/universalModuleDefinition","webpack://packer/./src/index.js","webpack://packer/webpack/bootstrap","webpack://packer/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"packer\"] = factory();\n\telse\n\t\troot[\"packer\"] = factory();\n})(self, () => {\nreturn ","const XBuffer = (typeof(Buffer) !== 'undefined' ? Buffer : (function() {\r\n    const MAX_ARGUMENTS_LENGTH = 0x1000;\r\n    const K_MAX_LENGTH = 0x7fffffff;\r\n\r\n    //---------------------]>\r\n\r\n    return (function() {\r\n        const Buffer = function() {};\r\n\r\n        //--------]>\r\n\r\n        Buffer.allocUnsafe = allocUnsafe;\r\n        Buffer.allocUnsafeSlow = allocUnsafe;\r\n\r\n        //--------]>\r\n\r\n        return Buffer;\r\n\r\n        //--------]>\r\n\r\n        function allocUnsafe(length) {\r\n            if(length > K_MAX_LENGTH) {\r\n                throw new RangeError('Invalid typed array length');\r\n            }\r\n\r\n            const buf = new Uint8Array(length);\r\n\r\n            buf.write = write;\r\n            buf.toString = toString;\r\n\r\n            return buf;\r\n        }\r\n\r\n        //----)>\r\n\r\n        function write(string, offset, length) {\r\n            offset = offset || 0;\r\n            length = length || this.length;\r\n\r\n            const remaining = this.length - offset;\r\n\r\n            if(!length || length > remaining) {\r\n                length = remaining;\r\n            }\r\n\r\n            return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);\r\n        }\r\n\r\n        function toString(encoding, start, end) {\r\n            start = start || 0;\r\n            end = end || this.length;\r\n\r\n            return end === 0 ? '' : utf8Slice(this, start, end);\r\n        }\r\n    })();\r\n\r\n    //---------------------]>\r\n\r\n    function utf8ToBytes(string, units) {\r\n        units = units || Infinity;\r\n\r\n        const length = string.length;\r\n\r\n        let codePoint;\r\n        let leadSurrogate = null;\r\n        let bytes = new Array();\r\n\r\n        for(let i = 0; i < length; ++i) {\r\n            codePoint = string.charCodeAt(i);\r\n\r\n            // is surrogate component\r\n            if(codePoint > 0xD7FF && codePoint < 0xE000) {\r\n                // last char was a lead\r\n                if(!leadSurrogate) {\r\n                    // no lead yet\r\n                    if(codePoint > 0xDBFF) {\r\n                        // unexpected trail\r\n                        if((units -= 3) > -1) {\r\n                            bytes.push(0xEF, 0xBF, 0xBD);\r\n                        }\r\n\r\n                        continue;\r\n                    }\r\n                    else if(i + 1 === length) {\r\n                        // unpaired lead\r\n                        if((units -= 3) > -1) {\r\n                            bytes.push(0xEF, 0xBF, 0xBD);\r\n                        }\r\n\r\n                        continue;\r\n                    }\r\n\r\n                    // valid lead\r\n                    leadSurrogate = codePoint;\r\n\r\n                    continue;\r\n                }\r\n\r\n                // 2 leads in a row\r\n                if(codePoint < 0xDC00) {\r\n                    if((units -= 3) > -1) {\r\n                        bytes.push(0xEF, 0xBF, 0xBD);\r\n                    }\r\n\r\n                    leadSurrogate = codePoint;\r\n\r\n                    continue;\r\n                }\r\n\r\n                // valid surrogate pair\r\n                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\r\n            }\r\n            else if(leadSurrogate) {\r\n                // valid bmp char, but last char was a lead\r\n                if((units -= 3) > -1) {\r\n                    bytes.push(0xEF, 0xBF, 0xBD);\r\n                }\r\n            }\r\n\r\n            leadSurrogate = null;\r\n\r\n            // encode utf8\r\n            if(codePoint < 0x80) {\r\n                if((units -= 1) < 0) {\r\n                    break;\r\n                }\r\n\r\n                bytes.push(codePoint);\r\n            }\r\n            else if(codePoint < 0x800) {\r\n                if((units -= 2) < 0) {\r\n                    break;\r\n                }\r\n\r\n                bytes.push(\r\n                    codePoint >> 0x6 | 0xC0,\r\n                    codePoint & 0x3F | 0x80\r\n                );\r\n            }\r\n            else if(codePoint < 0x10000) {\r\n                if((units -= 3) < 0) {\r\n                    break;\r\n                }\r\n\r\n                bytes.push(\r\n                    codePoint >> 0xC | 0xE0,\r\n                    codePoint >> 0x6 & 0x3F | 0x80,\r\n                    codePoint & 0x3F | 0x80\r\n                );\r\n            }\r\n            else if(codePoint < 0x110000) {\r\n                if((units -= 4) < 0) {\r\n                    break;\r\n                }\r\n\r\n                bytes.push(\r\n                    codePoint >> 0x12 | 0xF0,\r\n                    codePoint >> 0xC & 0x3F | 0x80,\r\n                    codePoint >> 0x6 & 0x3F | 0x80,\r\n                    codePoint & 0x3F | 0x80\r\n                );\r\n            }\r\n            else {\r\n                throw new Error('Invalid code point');\r\n            }\r\n        }\r\n\r\n        return bytes;\r\n    }\r\n\r\n    function utf8Slice(buf, start, end) {\r\n        end = Math.min(buf.length, end);\r\n\r\n        const res = new Array();\r\n        let i = start;\r\n\r\n        while(i < end) {\r\n            let firstByte = buf[i];\r\n            let codePoint = null;\r\n            let bytesPerSequence = (firstByte > 0xEF) ? 4\r\n                : (firstByte > 0xDF) ? 3\r\n                    : (firstByte > 0xBF) ? 2\r\n                        : 1;\r\n\r\n            if(i + bytesPerSequence <= end) {\r\n                let secondByte, thirdByte, fourthByte, tempCodePoint;\r\n\r\n                switch(bytesPerSequence) {\r\n                    case 1:\r\n                        if(firstByte < 0x80) {\r\n                            codePoint = firstByte;\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case 2:\r\n                        secondByte = buf[i + 1];\r\n\r\n                        if((secondByte & 0xC0) === 0x80) {\r\n                            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\r\n\r\n                            if(tempCodePoint > 0x7F) {\r\n                                codePoint = tempCodePoint;\r\n                            }\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case 3:\r\n                        secondByte = buf[i + 1];\r\n                        thirdByte = buf[i + 2];\r\n\r\n                        if((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n                            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\r\n\r\n                            if(tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n                                codePoint = tempCodePoint;\r\n                            }\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case 4:\r\n                        secondByte = buf[i + 1];\r\n                        thirdByte = buf[i + 2];\r\n                        fourthByte = buf[i + 3];\r\n\r\n                        if((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n                            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\r\n\r\n                            if(tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n                                codePoint = tempCodePoint;\r\n                            }\r\n                        }\r\n                }\r\n            }\r\n\r\n            if(codePoint === null) {\r\n                // we did not generate a valid codePoint so insert a\r\n                // replacement char (U+FFFD) and advance only 1 byte\r\n                codePoint = 0xFFFD;\r\n                bytesPerSequence = 1;\r\n            }\r\n            else if(codePoint > 0xFFFF) {\r\n                // encode to utf16 (surrogate pair dance)\r\n                codePoint -= 0x10000;\r\n                res.push(codePoint >>> 10 & 0x3FF | 0xD800);\r\n                codePoint = 0xDC00 | codePoint & 0x3FF;\r\n            }\r\n\r\n            res.push(codePoint);\r\n            i += bytesPerSequence;\r\n        }\r\n\r\n        return decodeCodePointsArray(res);\r\n    }\r\n\r\n    //--------)>\r\n\r\n    function decodeCodePointsArray(codePoints) {\r\n        const len = codePoints.length;\r\n\r\n        if(len <= MAX_ARGUMENTS_LENGTH) {\r\n            return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\r\n        }\r\n\r\n        // Decode in chunks to avoid 'call stack size exceeded'.\r\n        let res = '';\r\n        let i = 0;\r\n\r\n        while(i < len) {\r\n            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\r\n        }\r\n\r\n        return res;\r\n    }\r\n})());\r\n\r\nconst isBigEndian = (function() {\r\n    const a = new Uint32Array([0x12345678]);\r\n    const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\r\n\r\n    return b[0] === 0x12;\r\n})();\r\n\r\n//-----------------------------------------------------\r\n\r\nmodule.exports = function(schema) {\r\n    const TYPE_BIN      = 1;\r\n    const TYPE_STR      = 2;\r\n    const TYPE_INT      = 4;\r\n    const TYPE_UINT     = 8;\r\n    const TYPE_FLOAT    = 16;\r\n    const TYPE_JSON     = 32;\r\n\r\n    //-----------------]>\r\n\r\n    if(schema === null) {\r\n        schema = [];\r\n    }\r\n\r\n    if(!schema || !Array.isArray(schema) && typeof(schema) !== 'string') {\r\n        throw new Error('Invalid schema');\r\n    }\r\n\r\n    //-----------------]>\r\n\r\n    const schemaContNames = Array.isArray(schema) ? schema.some((e) => e.split(':').length >= 2) : false;\r\n    const schemaDontContNames = Array.isArray(schema) ? schema.some((e) => e.split(':').length < 2) : true;\r\n\r\n    //-----------------]>\r\n\r\n    if(schemaContNames && schemaDontContNames) {\r\n        throw new Error('A schema has mixed names/types');\r\n    }\r\n\r\n    //-----------------]>\r\n\r\n    const int64size     = typeof(BigInt64Array) !== 'undefined' ? BigInt64Array.BYTES_PER_ELEMENT : 0;\r\n\r\n    const isPrimitive   = typeof(schema) === 'string';\r\n    const schLen        = isPrimitive ? 1 : schema.length;\r\n\r\n    const fields        = new Array(schLen);\r\n\r\n    //---------)>\r\n\r\n    let pktDataBuf      = null;\r\n    let pktOffset       = 0;\r\n    let pktMinSize      = 0;\r\n    let pktMaxSize      = 0;\r\n\r\n    let pktDataHolderArr = new Array();\r\n    let pktDataHolderObj = Object.create(null);\r\n\r\n    //-----------------]>\r\n\r\n    for(let i = 0; i < schLen; ++i) {\r\n        const [subType, name] = isPrimitive ? [schema, ''] : schema[i].split(':').reverse();\r\n\r\n        const type = getTypeId(subType.replace(/[\\d\\[\\]]/g, ''));\r\n        const size = parseInt(subType.replace(/\\D/g, ''), 10) || 0;\r\n\r\n        const [\r\n            bytes,   // BYTES_PER_ELEMENT\r\n            bufType, // dataView\r\n            bufAType // dataSizeView\r\n        ] = buildTypedBuf(type, size);\r\n\r\n        const bufBytes = ((type & TYPE_STR) === TYPE_STR || (type & TYPE_BIN) === TYPE_BIN) ? null : new Uint8Array(bufType.buffer);\r\n        const bufABytes = bufAType ? new Uint8Array(bufAType.buffer) : null;\r\n\r\n        //---------]>\r\n\r\n        fields[i] = [name, type, bytes, bufType, bufBytes, bufAType, bufABytes];\r\n\r\n        pktMinSize += bytes;\r\n        pktMaxSize += bufType.byteLength;\r\n    }\r\n\r\n    offset(0);\r\n\r\n    //-----------------]>\r\n\r\n    return {\r\n        get minSize() { return pktMinSize; },\r\n        get maxSize() { return pktMaxSize; },\r\n\r\n        get offset() { return pktOffset; },\r\n        set offset(value) { offset(value); },\r\n\r\n        pack,\r\n        unpack\r\n    };\r\n\r\n    //-----------------]>\r\n\r\n    function offset(value) {\r\n        value = parseInt(value, 10) || 0;\r\n\r\n        pktMinSize = (pktMinSize - pktOffset) + value;\r\n        pktMaxSize = (pktMaxSize - pktOffset) + value;\r\n        pktOffset = value;\r\n\r\n        pktDataBuf = XBuffer.allocUnsafeSlow(pktMaxSize);\r\n    }\r\n\r\n    //------)>\r\n\r\n    /**\r\n     *\r\n     * @param {(Array|Object)} data\r\n     * @param {(undefined|Buffer)} target\r\n     * @returns {(Buffer)} Browser Buffer - Uint8Array\r\n     */\r\n    function pack(data, target) {\r\n        const isArray = Array.isArray(data);\r\n        const outTg = !!target;\r\n\r\n        let fieldIdx = schLen;\r\n        let pktSize = pktOffset;\r\n\r\n        let input = data;\r\n\r\n        let field;\r\n        let name, type, bytes, bufType, bufBytes, bufAType, bufABytes;\r\n\r\n        //--------]>\r\n\r\n        target = target || pktDataBuf;\r\n\r\n        //--------]>\r\n\r\n        while(fieldIdx--) {\r\n            field = fields[fieldIdx];\r\n            [name, type, bytes, bufType, bufBytes, bufAType, bufABytes] = field;\r\n\r\n            //------]>\r\n\r\n            if(!isPrimitive && data) {\r\n                input = data[isArray ? fieldIdx : name];\r\n            }\r\n\r\n            //------]>\r\n\r\n            if((type & TYPE_STR) === TYPE_STR || (type & TYPE_BIN) === TYPE_BIN) {\r\n                if((type & TYPE_JSON) === TYPE_JSON) {\r\n                    input = JSON.stringify(input);\r\n                }\r\n\r\n                if(input) {\r\n                    bytes += bufAType[0] = ((type & TYPE_BIN) === TYPE_BIN)\r\n                        ? blitBuffer(input, target, pktSize + bytes, bufType.byteLength - bytes)\r\n                        : target.write(input, pktSize + bytes, bufType.byteLength - bytes);\r\n\r\n                    if(isBigEndian) {\r\n                        target[pktSize] = bufABytes[1];\r\n                        target[pktSize + 1] = bufABytes[0];\r\n                    }\r\n                    else {\r\n                        target[pktSize] = bufABytes[0];\r\n                        target[pktSize + 1] = bufABytes[1];\r\n                    }\r\n\r\n                    pktSize += bytes;\r\n\r\n                }\r\n                else {\r\n                    target[pktSize] = 0;\r\n                    target[pktSize + 1] = 0;\r\n\r\n                    pktSize += 2;\r\n                }\r\n            }\r\n            else {\r\n                let zeroValue = 0;\r\n\r\n                if(bytes === int64size) {\r\n                    zeroValue = BigInt('0');\r\n                }\r\n\r\n                if(input == null || typeof(input) !== 'bigint' && (isNaN(input) || !isFinite(input))) {\r\n                    bufType[0] = zeroValue;\r\n                }\r\n                else {\r\n                    bufType[0] = input;\r\n\r\n                    if(isBigEndian && bufType.byteLength > 1) {\r\n                        bufBytes.reverse();\r\n                    }\r\n                }\r\n\r\n                let tIdx = 0;\r\n\r\n                while(tIdx < bytes) {\r\n                    target[pktSize] = bufBytes[tIdx];\r\n\r\n                    ++pktSize;\r\n                    ++tIdx;\r\n                }\r\n            }\r\n        }\r\n\r\n        //--------]>\r\n\r\n        return !outTg && pktSize < pktMaxSize ? target.slice(0, pktSize) : target;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {(Uint8Array|Buffer)} bin\r\n     * @param {number} offset\r\n     * @param {number} length\r\n     * @param {Function} cbEndInfo\r\n     * @param {(Array|Object)} target\r\n     * @param {boolean} asCopy\r\n     * @param {boolean} asArray\r\n     * @returns {(undefined|null|Array|Object)}\r\n     */\r\n    function unpack(bin, offset, length, cbEndInfo, target, asCopy = true, asArray = false) {\r\n        if(!schLen) {\r\n            if(cbEndInfo) {\r\n                cbEndInfo(pktOffset);\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        //--------]>\r\n\r\n        if(!bin || typeof(bin) !== 'object' || bin.byteLength < pktMinSize) {\r\n            return undefined;\r\n        }\r\n\r\n        if(schemaDontContNames) {\r\n            asArray = true;\r\n        }\r\n\r\n        if(!isPrimitive) {\r\n            target = target || (asCopy ? (asArray ? new Array() : Object.create(null)) : (asArray ? pktDataHolderArr : pktDataHolderObj));\r\n        }\r\n\r\n        //--------]>\r\n\r\n        let fieldIdx = schLen;\r\n        let curOffset = offset + pktOffset;\r\n\r\n        const pktOffsetStart = curOffset;\r\n\r\n        //--------]>\r\n\r\n        while(fieldIdx--) {\r\n            let field;\r\n            let [name, type, bytes, bufType, bufBytes, bufAType, bufABytes] = fields[fieldIdx];\r\n\r\n            //------]>\r\n\r\n            for(let i = 0; i < bytes; ++i) {\r\n                if(curOffset >= length) {\r\n                    return undefined;\r\n                }\r\n\r\n                if(bufAType) {\r\n                    bufABytes[i] = bin[curOffset];\r\n                }\r\n                else {\r\n                    bufBytes[i] = bin[curOffset];\r\n                }\r\n\r\n                ++curOffset;\r\n            }\r\n\r\n            //------]>\r\n\r\n            if((type & TYPE_STR) === TYPE_STR || (type & TYPE_BIN) === TYPE_BIN) {\r\n                if(isBigEndian) {\r\n                    bufABytes.reverse();\r\n                }\r\n\r\n                //--------]>\r\n\r\n                const byteLen = bufAType[0];\r\n\r\n                //--------]>\r\n\r\n                if(!byteLen) {\r\n                    field = (type & TYPE_BIN) === TYPE_BIN || (type & TYPE_JSON) === TYPE_JSON ? null : '';\r\n                }\r\n                else if(byteLen >= length || byteLen > bufType.byteLength) {\r\n                    return undefined;\r\n                }\r\n                else {\r\n                    if((type & TYPE_BIN) === TYPE_BIN) {\r\n                        const buf = XBuffer.allocUnsafeSlow(byteLen);\r\n\r\n                        for(let i = 0; i < byteLen; ++i, ++curOffset) {\r\n                            buf[i] = bin[curOffset];\r\n                        }\r\n\r\n                        field = buf;\r\n                    }\r\n                    else {\r\n                        if(bin instanceof(XBuffer)) {\r\n                            field = bin.toString('utf8', curOffset, curOffset + byteLen);\r\n                        }\r\n                        else if(XBuffer.from) {\r\n                            field = XBuffer.from(bin).toString('utf8', curOffset, curOffset + byteLen);\r\n                        }\r\n                        else if(typeof(TextDecoder) !== 'undefined') {\r\n                            field = (new TextDecoder()).decode(bin.slice(curOffset, curOffset + byteLen).buffer)\r\n                        }\r\n                        else {\r\n                            field = bufType.toString.call(bin, 'utf8', curOffset, curOffset + byteLen);\r\n                        }\r\n\r\n                        curOffset += byteLen;\r\n                    }\r\n\r\n                    if((type & TYPE_JSON) === TYPE_JSON) {\r\n                        try {\r\n                            field = JSON.parse(field);\r\n                        }\r\n                        catch(e) {\r\n                            field = null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if(isBigEndian && bufType.byteLength > 1) {\r\n                    bufBytes.reverse();\r\n                }\r\n\r\n                field = bufType[0];\r\n            }\r\n\r\n            //------]>\r\n\r\n            if(isPrimitive) {\r\n                target = field;\r\n            }\r\n            else {\r\n                if(asArray) {\r\n                    name = fieldIdx;\r\n                }\r\n\r\n                target[name] = field;\r\n            }\r\n        }\r\n\r\n        if(cbEndInfo) {\r\n            cbEndInfo(pktOffset + curOffset - pktOffsetStart);\r\n        }\r\n\r\n        //--------]>\r\n\r\n        return target;\r\n    }\r\n\r\n    //-----------------]>\r\n\r\n    function buildTypedBuf(type, size) {\r\n        if((type & TYPE_BIN) === TYPE_BIN) {\r\n            return [Uint16Array.BYTES_PER_ELEMENT, XBuffer.allocUnsafeSlow((size || 1024) + Uint16Array.BYTES_PER_ELEMENT), new Uint16Array(1)];\r\n        }\r\n\r\n        if((type & TYPE_JSON) === TYPE_JSON) {\r\n            return [Uint16Array.BYTES_PER_ELEMENT, XBuffer.allocUnsafeSlow((size || 8192) + Uint16Array.BYTES_PER_ELEMENT), new Uint16Array(1)];\r\n        }\r\n\r\n        if((type & TYPE_STR) === TYPE_STR) {\r\n            return [Uint16Array.BYTES_PER_ELEMENT, XBuffer.allocUnsafeSlow((size || 256) + Uint16Array.BYTES_PER_ELEMENT), new Uint16Array(1)];\r\n        }\r\n\r\n        switch(type) {\r\n            case TYPE_INT:\r\n                switch(size) {\r\n                    case 8: return [Int8Array.BYTES_PER_ELEMENT, new Int8Array(1)];\r\n                    case 16: return [Int16Array.BYTES_PER_ELEMENT, new Int16Array(1)];\r\n                    case 32: return [Int32Array.BYTES_PER_ELEMENT, new Int32Array(1)];\r\n                    case 64: return [BigInt64Array.BYTES_PER_ELEMENT, new BigInt64Array(1)];\r\n\r\n                    default:\r\n                        throw new Error(`Unknown size: ${size} | ${type}`);\r\n                }\r\n\r\n\r\n            case TYPE_UINT:\r\n                switch(size) {\r\n                    case 8: return [Uint8Array.BYTES_PER_ELEMENT, new Uint8Array(1)];\r\n                    case 16: return [Uint16Array.BYTES_PER_ELEMENT, new Uint16Array(1)];\r\n                    case 32: return [Uint32Array.BYTES_PER_ELEMENT, new Uint32Array(1)];\r\n                    case 64: return [BigUint64Array.BYTES_PER_ELEMENT, new BigUint64Array(1)];\r\n\r\n                    default:\r\n                        throw new Error(`Unknown size: ${size} | ${type}`);\r\n                }\r\n\r\n\r\n            case TYPE_FLOAT:\r\n                switch(size) {\r\n                    case 32: return [Float32Array.BYTES_PER_ELEMENT, new Float32Array(1)];\r\n                    case 64: return [Float64Array.BYTES_PER_ELEMENT, new Float64Array(1)];\r\n\r\n                    default:\r\n                        throw new Error(`Unknown size: ${size} | ${type}`);\r\n                }\r\n\r\n            default:\r\n                throw new Error(`Unknown type: ${type} | ${type}`);\r\n        }\r\n    }\r\n\r\n    function getTypeId(type) {\r\n        switch(type) {\r\n            case 'b':\r\n            case 'bin':\r\n                return TYPE_BIN;\r\n\r\n            case 'j':\r\n            case 'json':\r\n                return TYPE_STR | TYPE_JSON;\r\n\r\n            case 's':\r\n            case 'str':\r\n                return TYPE_STR;\r\n\r\n            case 'i':\r\n            case 'int':\r\n                return TYPE_INT;\r\n\r\n            case 'u':\r\n            case 'uint':\r\n                return TYPE_UINT;\r\n\r\n            case 'f':\r\n            case 'float':\r\n                return TYPE_FLOAT;\r\n\r\n            default:\r\n                throw new Error(`Unknown type: ${type}`);\r\n        }\r\n    }\r\n}\r\n\r\n//---]>\r\n\r\nObject.assign(module.exports, {\r\n    get isBE() { return isBigEndian; },\r\n    get isLE() { return !isBigEndian; }\r\n})\r\n\r\n//-----------------------------------------------------\r\n\r\nfunction blitBuffer(src, dst, offset, length) {\r\n    if(!length) {\r\n        return 0;\r\n    }\r\n\r\n    //-------]>\r\n\r\n    const dstLen = dst.length;\r\n    const srcLen = src.length;\r\n\r\n    let i, t;\r\n\r\n    //-------]>\r\n\r\n    for(i = 0; i < length; ++i) {\r\n        t = i + offset;\r\n\r\n        if(t >= dstLen || i >= srcLen) {\r\n            break;\r\n        }\r\n\r\n        dst[t] = src[i];\r\n    }\r\n\r\n    //-------]>\r\n\r\n    return i;\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(579);\n"],"names":["root","factory","exports","module","define","amd","self","MAX_ARGUMENTS_LENGTH","a","XBuffer","Buffer","allocUnsafe","allocUnsafeSlow","length","RangeError","buf","Uint8Array","write","toString","string","offset","this","remaining","blitBuffer","units","Infinity","codePoint","leadSurrogate","bytes","Array","i","charCodeAt","push","Error","utf8ToBytes","encoding","start","end","Math","min","res","firstByte","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","len","String","fromCharCode","apply","slice","decodeCodePointsArray","utf8Slice","isBigEndian","Uint32Array","buffer","byteOffset","byteLength","src","dst","t","dstLen","srcLen","schema","TYPE_JSON","isArray","schemaContNames","some","e","split","schemaDontContNames","int64size","BigInt64Array","BYTES_PER_ELEMENT","isPrimitive","schLen","fields","pktDataBuf","pktOffset","pktMinSize","pktMaxSize","pktDataHolderArr","pktDataHolderObj","Object","create","reverse","subType","name","type","getTypeId","replace","buildTypedBuf","parseInt","bufType","bufAType","bufBytes","bufABytes","minSize","maxSize","value","pack","data","target","outTg","fieldIdx","pktSize","input","JSON","stringify","zeroValue","BigInt","isNaN","isFinite","tIdx","unpack","bin","cbEndInfo","asCopy","asArray","curOffset","pktOffsetStart","field","byteLen","from","TextDecoder","decode","call","parse","size","Uint16Array","Int8Array","Int16Array","Int32Array","BigUint64Array","Float32Array","Float64Array","TYPE_STR","assign","isBE","isLE","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}